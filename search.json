[{"title":"Containerd Image 服务","path":"/2023/01/16/Containerd_Image/","content":"概述Containerd Image 服务提供了容器镜像的管理功能，如查看镜像信息、列出镜像列表、更新&#x2F;删除镜像以及保存镜像信息。此服务核心功能是提供镜像的元数据的管理操作，bolt KV存储模块作为后端元数据存储。 Images 插件注册gRPC images server 接口定义 api&#x2F;services&#x2F;images&#x2F;v1&#x2F;images.pb.go:605 12345678910111213141516// ImagesServer is the server API for Images service.type ImagesServer interface &#123;\t// Get returns an image by name.\tGet(context.Context, *GetImageRequest) (*GetImageResponse, error)\t// List returns a list of all images known to containerd.\tList(context.Context, *ListImagesRequest) (*ListImagesResponse, error)\t// Create an image record in the metadata store.\t//\t// The name of the image must be unique.\tCreate(context.Context, *CreateImageRequest) (*CreateImageResponse, error)\t// Update assigns the name to a given target image based on the provided\t// image.\tUpdate(context.Context, *UpdateImageRequest) (*UpdateImageResponse, error)\t// Delete deletes the image by name.\tDelete(context.Context, *DeleteImageRequest) (*types1.Empty, error)&#125; 注册 gRPC image server services&#x2F;images&#x2F;service.go:30 123456789101112131415161718192021222324func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.GRPCPlugin, // gRPC 插件类型 ID: &quot;images&quot;, Requires: []plugin.Type&#123; plugin.ServicePlugin, // 依赖服务类型插件 &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; plugins, err := ic.GetByType(plugin.ServicePlugin) // 获取所有服务类型插件 if err != nil &#123; return nil, err &#125; p, ok := plugins[services.ImagesService] // 获取已注册 key 为 &quot;images-service&quot; 服务插件 if !ok &#123; return nil, errors.New(&quot;images service not found&quot;) &#125; i, err := p.Instance() // 服务初始化返回实例对象 if err != nil &#123; return nil, err &#125; return &amp;service&#123;local: i.(imagesapi.ImagesClient)&#125;, nil &#125;,\t&#125;)&#125; services&#x2F;images&#x2F;service.go:61 1234func (s *service) Register(server *grpc.Server) error &#123;\timagesapi.RegisterImagesServer(server, s)\treturn nil&#125; images service 类型插件注册 123456789101112131415161718192021222324252627func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.ServicePlugin, ID: services.ImagesService, // &quot;images-service&quot; 服务 Requires: []plugin.Type&#123; plugin.MetadataPlugin, // 元数据库插件依赖 plugin.GCPlugin, // GC调度插件依赖 &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; m, err := ic.Get(plugin.MetadataPlugin) // 获取元数据库对象 if err != nil &#123; return nil, err &#125; g, err := ic.Get(plugin.GCPlugin) // 获取 GC 调度器对象 if err != nil &#123; return nil, err &#125; // 返回 imagesapi.ImagesClient 接口实现类对象 return &amp;local&#123; store: metadata.NewImageStore(m.(*metadata.DB)), // 创建镜像存储 publisher: ic.Events, // 事件发布器 gc: g.(gcScheduler), // GC调度器 &#125;, nil &#125;,\t&#125;)&#125; imageStore 存储对象构建 1234// NewImageStore returns a store backed by a bolt DBfunc NewImageStore(db *DB) images.Store &#123;\treturn &amp;imageStore&#123;db: db&#125;&#125; imageStore 内的唯一属性 DB 类型定义 metadata&#x2F;db.go:67 1234567891011121314151617181920212223242526272829// DB represents a metadata database backed by a bolt// database. The database is fully namespaced and stores// image, container, namespace, snapshot, and content data// while proxying data shared across namespaces to backend// datastores for content and snapshots.type DB struct &#123;\tdb *bolt.DB\tss map[string]*snapshotter\tcs *contentStore\t// wlock is used to protect access to the data structures during garbage\t// collection. While the wlock is held no writable transactions can be\t// opened, preventing changes from occurring between the mark and\t// sweep phases without preventing read transactions.\twlock sync.RWMutex\t// dirty flags and lock keeps track of datastores which have had deletions\t// since the last garbage collection. These datastores will will be garbage\t// collected during the next garbage collection.\tdirtyL sync.Mutex\tdirtySS map[string]struct&#123;&#125;\tdirtyCS bool\t// mutationCallbacks are called after each mutation with the flag\t// set indicating whether any dirty flags are set\tmutationCallbacks []func(bool)\tdbopts dbOptions&#125; images service 服务方法实现调用了 imageStore 的方法 1234567891011121314151617181920func (l *local) Update(ctx context.Context, req *imagesapi.UpdateImageRequest, _ ...grpc.CallOption) (*imagesapi.UpdateImageResponse, error) &#123; //... // 调用了 local.store 镜像存储实现 imageStore 的方法\tupdated, err := l.store.Update(ctx, image, fieldpaths...)\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125;\tresp.Image = imageToProto(&amp;updated)\tif err := l.publisher.Publish(ctx, &quot;/images/update&quot;, &amp;eventstypes.ImageUpdate&#123; Name: resp.Image.Name, Labels: resp.Image.Labels,\t&#125;); err != nil &#123; return nil, err\t&#125;\treturn &amp;resp, nil&#125; ImageStore 镜像存储管理metadata&#x2F;images.go:38 123type imageStore struct &#123;\tdb *DB&#125; images&#x2F;image.go:77 1234567type Store interface &#123; Get(ctx context.Context, name string) (Image, error) List(ctx context.Context, filters ...string) ([]Image, error) Create(ctx context.Context, image Image) (Image, error) Update(ctx context.Context, image Image, fieldpaths ...string) (Image, error) Delete(ctx context.Context, name string, opts ...DeleteOpt) error&#125; imageStore 实现方法 Get() metadata&#x2F;images.go:47 12345678910111213141516171819202122232425262728293031323334func (s *imageStore) Get(ctx context.Context, name string) (images.Image, error) &#123;\tvar image images.Image // 通过上下文件，获取命名空间\tnamespace, err := namespaces.NamespaceRequired(ctx)\tif err != nil &#123; return images.Image&#123;&#125;, err\t&#125;\tif err := view(ctx, s.db, func(tx *bolt.Tx) error &#123; // 获取指定命名空间镜像 bucket 对象 bkt := getImagesBucket(tx, namespace) if bkt == nil &#123; return errors.Wrapf(errdefs.ErrNotFound, &quot;image %q&quot;, name) &#125; // 按条件 name 在 bucket 内检索 ibkt := bkt.Bucket([]byte(name)) if ibkt == nil &#123; return errors.Wrapf(errdefs.ErrNotFound, &quot;image %q&quot;, name) &#125; image.Name = name // 从元数据库内，读取镜像信息 if err := readImage(&amp;image, ibkt); err != nil &#123; return errors.Wrapf(err, &quot;image %q&quot;, name) &#125; return nil\t&#125;); err != nil &#123; return images.Image&#123;&#125;, err\t&#125;\treturn image, nil // 返回 image 结构化对象 （后面有详细分析 image 类定义）&#125; metadata&#x2F;images.go:300 12345678910111213141516171819202122232425262728293031323334353637383940func readImage(image *images.Image, bkt *bolt.Bucket) error &#123; // image 创建时间和更新时间获取\tif err := boltutil.ReadTimestamps(bkt, &amp;image.CreatedAt, &amp;image.UpdatedAt); err != nil &#123; return err\t&#125; // 标签获取\tlabels, err := boltutil.ReadLabels(bkt)\tif err != nil &#123; return err\t&#125;\timage.Labels = labels // 注解项读取\timage.Target.Annotations, err = boltutil.ReadAnnotations(bkt)\tif err != nil &#123; return err\t&#125; // Target 镜像 root 内容读取\ttbkt := bkt.Bucket(bucketKeyTarget)\tif tbkt == nil &#123; return errors.New(&quot;unable to read target bucket&quot;)\t&#125;\treturn tbkt.ForEach(func(k, v []byte) error &#123; if v == nil &#123; return nil // skip it? a bkt maybe? &#125; switch string(k) &#123; case string(bucketKeyDigest): image.Target.Digest = digest.Digest(v) // Target 摘要哈希值 case string(bucketKeyMediaType): image.Target.MediaType = string(v) // media 类型 case string(bucketKeySize): image.Target.Size, _ = binary.Varint(v) // 大小值 &#125; return nil\t&#125;)&#125; imageStore 实现方法 Create() metadata&#x2F;images.go:121 1234567891011121314151617181920212223242526272829303132333435363738func (s *imageStore) Create(ctx context.Context, image images.Image) (images.Image, error) &#123;\tnamespace, err := namespaces.NamespaceRequired(ctx)\tif err != nil &#123; return images.Image&#123;&#125;, err\t&#125;\tif err := update(ctx, s.db, func(tx *bolt.Tx) error &#123; if err := validateImage(&amp;image); err != nil &#123; return err &#125; // 在命名空间下创建镜像 bucket 对象 bkt, err := createImagesBucket(tx, namespace) if err != nil &#123; return err &#125; // 基于镜像名创建存储 bucket ibkt, err := bkt.CreateBucket([]byte(image.Name)) if err != nil &#123; if err != bolt.ErrBucketExists &#123; return err &#125; return errors.Wrapf(errdefs.ErrAlreadyExists, &quot;image %q&quot;, image.Name) &#125; image.CreatedAt = time.Now().UTC() // 镜像创建时间 image.UpdatedAt = image.CreatedAt // 镜像更新时间 // +镜像存至元数据库 return writeImage(ibkt, &amp;image)\t&#125;); err != nil &#123; return images.Image&#123;&#125;, err\t&#125;\treturn image, nil&#125; metadata&#x2F;images.go:340 123456789101112131415161718192021222324252627282930313233343536373839func writeImage(bkt *bolt.Bucket, image *images.Image) error &#123; // 写入 bucket 镜像创建时间和更新时间\tif err := boltutil.WriteTimestamps(bkt, image.CreatedAt, image.UpdatedAt); err != nil &#123; return err\t&#125; // 写入 bucket 镜像标签\tif err := boltutil.WriteLabels(bkt, image.Labels); err != nil &#123; return errors.Wrapf(err, &quot;writing labels for image %v&quot;, image.Name)\t&#125; // 写入 bucket 镜像注解\tif err := boltutil.WriteAnnotations(bkt, image.Target.Annotations); err != nil &#123; return errors.Wrapf(err, &quot;writing Annotations for image %v&quot;, image.Name)\t&#125; // 获取或创建 target bucket\ttbkt, err := bkt.CreateBucketIfNotExists(bucketKeyTarget)\tif err != nil &#123; return err\t&#125; // 镜像 target 大小值\tsizeEncoded, err := encodeInt(image.Target.Size)\tif err != nil &#123; return err\t&#125; // target bucket 写入 Target 摘要 HASH 、类型、大小 for _, v := range [][2][]byte&#123; &#123;bucketKeyDigest, []byte(image.Target.Digest)&#125;, &#123;bucketKeyMediaType, []byte(image.Target.MediaType)&#125;, &#123;bucketKeySize, sizeEncoded&#125;,\t&#125; &#123; if err := tbkt.Put(v[0], v[1]); err != nil &#123; return err &#125;\t&#125;\treturn nil&#125; Image 镜像类型定义Image 结构类型定义与底层方法 image 为 containerd 提供了对一个镜像结构化描述，以便于对镜像对象表示、查看等标准化操作 images&#x2F;image.go:36 12345678910type Image struct &#123;\t// 镜像名\tName string //标签\tLabels map[string]string // Target 描述了一个镜像的根内容，常指一个 manifest、index 或 manifest 列表类型内容描述符\tTarget ocispec.Descriptor // 创建与更新时间\tCreatedAt, UpdatedAt time.Time&#125; Config 解析出镜像的配置描述符 images&#x2F;image.go:97 1234// 输入参数为描述符为 image Target func (image *Image) Config(ctx context.Context, provider content.Provider, platform platforms.MatchComparer) (ocispec.Descriptor, error) &#123; return Config(ctx, provider, image.Target, platform) // +调用 Config()，解析镜像 manifest 返回 config Descriptor&#125; images&#x2F;image.go:251 123456789func Config(ctx context.Context, provider content.Provider, image ocispec.Descriptor, platform platforms.MatchComparer) (ocispec.Descriptor, error) &#123; // 解析 manifest\tmanifest, err := Manifest(ctx, provider, image, platform)\tif err != nil &#123; return ocispec.Descriptor&#123;&#125;, err\t&#125; // 返回 config Descriptor\treturn manifest.Config, err &#125; RootFS 返回解包后组成镜像 rootfs 的 diffids, 这些 diff id 值将用于对各镜像层 layer 内容的效验。 images&#x2F;image.go:105 1234567func (image *Image) RootFS(ctx context.Context, provider content.Provider, platform platforms.MatchComparer) ([]digest.Digest, error) &#123;\tdesc, err := image.Config(ctx, provider, platform)\tif err != nil &#123; return nil, err\t&#125; return RootFS(ctx, provider, desc) //+调用 RootFS()，读取内容 blob 解析并返回 DiffIDs&#125; images&#x2F;image.go:381 123456789101112131415func RootFS(ctx context.Context, provider content.Provider, configDesc ocispec.Descriptor) ([]digest.Digest, error) &#123; // 返回来自于 provider 提供的整个内容 blob p, err := content.ReadBlob(ctx, provider, configDesc)\tif err != nil &#123; return nil, err\t&#125;\tvar config ocispec.Image // json 格式化解析成 config if err := json.Unmarshal(p, &amp;config); err != nil &#123; return nil, err\t&#125; // 返回 DiffIDs\treturn config.RootFS.DiffIDs, nil &#125; Image 容器镜像管理Image 容器镜像管理接口定义 1234567891011121314151617181920212223// Image describes an image used by containerstype Image interface &#123;\t// Name of the image\tName() string\t// Target descriptor for the image content\tTarget() ocispec.Descriptor\t// Labels of the image\tLabels() map[string]string\t// Unpack unpacks the image&#x27;s content into a snapshot\tUnpack(context.Context, string, ...UnpackOpt) error\t// RootFS returns the unpacked diffids that make up images rootfs.\tRootFS(ctx context.Context) ([]digest.Digest, error)\t// Size returns the total size of the image&#x27;s packed resources.\tSize(ctx context.Context) (int64, error)\t// Usage returns a usage calculation for the image.\tUsage(context.Context, ...UsageOpt) (int64, error)\t// Config descriptor for the image.\tConfig(ctx context.Context) (ocispec.Descriptor, error)\t// IsUnpacked returns whether or not an image is unpacked.\tIsUnpacked(context.Context, string) (bool, error)\t// ContentStore provides a content store which contains image blob data\tContentStore() content.Store&#125; Image 操作接口的同名实现类 image 定义 image.go:126 12345type image struct &#123;\tclient *Client\ti images.Image // 同名 Image 结构类型\tplatform platforms.MatchComparer&#125; image 类对象构建 NewImage() 、NewImageWithPlatform() image.go:109 1234567891011121314151617// NewImage returns a client image object from the metadata imagefunc NewImage(client *Client, i images.Image) Image &#123;\treturn &amp;image&#123; client: client, i: i, platform: platforms.Default(),\t&#125;&#125;// NewImageWithPlatform returns a client image object from the metadata imagefunc NewImageWithPlatform(client *Client, i images.Image, platform platforms.MatchComparer) Image &#123;\treturn &amp;image&#123; client: client, i: i, platform: platform, // 平台版本对比器\t&#125;&#125; image 类关键的几个实现方法 image.go:145 1234func (i *image) RootFS(ctx context.Context) ([]digest.Digest, error) &#123;\tprovider := i.client.ContentStore()\treturn i.i.RootFS(ctx, provider, i.platform) // 调用 image 类型的底层方法，前面已述&#125; image.go:242 1234func (i *image) Config(ctx context.Context) (ocispec.Descriptor, error) &#123;\tprovider := i.client.ContentStore()\treturn i.i.Config(ctx, provider, i.platform) // 调用 image 类型的底层方法，前面已述&#125; image.go:154 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778func (i *image) Unpack(ctx context.Context, snapshotterName string, opts ...UnpackOpt) error &#123;\tctx, done, err := i.client.WithLease(ctx)\tif err != nil &#123; return err\t&#125;\tdefer done(ctx)\tvar config UnpackConfig\tfor _, o := range opts &#123; if err := o(ctx, &amp;config); err != nil &#123; return err &#125;\t&#125; // +getLayers() 获取所有镜像层\tlayers, err := i.getLayers(ctx, i.platform)\tif err != nil &#123; return err\t&#125;\tvar ( a = i.client.DiffService() // Diff 服务对象 cs = i.client.ContentStore() // 镜像内容存储对象 chain []digest.Digest unpacked bool\t)\tsnapshotterName, err = i.client.resolveSnapshotterName(ctx, snapshotterName)\tif err != nil &#123; return err\t&#125; // 获取快照管理器对象 sn, err := i.client.getSnapshotter(ctx, snapshotterName)\tif err != nil &#123; return err\t&#125; // 遍历所有镜像层\tfor _, layer := range layers &#123; // 将所有 layer 应用到 snapshot 上 unpacked, err = rootfs.ApplyLayerWithOpts(ctx, layer, chain, sn, a, config.SnapshotOpts, config.ApplyOpts) if err != nil &#123; return err &#125; // 更新 layer 内容存储元信息 if unpacked &#123; cinfo := content.Info&#123; Digest: layer.Blob.Digest, Labels: map[string]string&#123; &quot;containerd.io/uncompressed&quot;: layer.Diff.Digest.String(), &#125;, &#125; if _, err := cs.Update(ctx, cinfo, &quot;labels.containerd.io/uncompressed&quot;); err != nil &#123; return err &#125; &#125; chain = append(chain, layer.Diff.Digest)\t&#125;\tdesc, err := i.i.Config(ctx, cs, i.platform)\tif err != nil &#123; return err\t&#125;\trootfs := identity.ChainID(chain).String()\tcinfo := content.Info&#123; Digest: desc.Digest, Labels: map[string]string&#123; fmt.Sprintf(&quot;containerd.io/gc.ref.snapshot.%s&quot;, snapshotterName): rootfs, &#125;,\t&#125; // 更新 snapshot 内容元信息\t_, err = cs.Update(ctx, cinfo, fmt.Sprintf(&quot;labels.containerd.io/gc.ref.snapshot.%s&quot;, snapshotterName))\treturn err&#125; getLayers() 获取所有镜像层 image.go:356 123456789101112131415161718192021222324252627282930func (i *image) getLayers(ctx context.Context, platform platforms.MatchComparer) ([]rootfs.Layer, error) &#123;\tcs := i.client.ContentStore() // 解析镜像 manifest\tmanifest, err := images.Manifest(ctx, cs, i.i.Target, platform)\tif err != nil &#123; return nil, err\t&#125; // 获取镜像 rootfs 的 diffid 列表\tdiffIDs, err := i.i.RootFS(ctx, cs, platform)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to resolve rootfs&quot;)\t&#125;\tif len(diffIDs) != len(manifest.Layers) &#123; return nil, errors.Errorf(&quot;mismatched image rootfs and manifest layers&quot;)\t&#125; // 通过迭代 diffIDs，获取镜像的所有 layer (diff+blob)\tlayers := make([]rootfs.Layer, len(diffIDs))\tfor i := range diffIDs &#123; layers[i].Diff = ocispec.Descriptor&#123; // TODO: derive media type from compressed type MediaType: ocispec.MediaTypeImageLayer, Digest: diffIDs[i], &#125; layers[i].Blob = manifest.Layers[i]\t&#125;\treturn layers, nil&#125; Ctr images pull 拉取镜像实例在 image 拉取完成后使用相同的 ref 引用参数可供容器运行 run 命令使用。pull 镜像拉取过程包含以下三点处理： 拉取所有镜像的资源(元信息、内容blob)到 containers 为拉取的资源准备快照文件系统 （ rootfs 文件系统） 将为拉取的镜像注册到本地 元数据库存储内 下面仅简单分析一下 pull 子命令顶层的代码，了解一下整个 image 从远端仓库到本地存储的逻辑过程，此过程将 containerd 的 images 、diff 、content 、snapshot 服务功能模块都有联合应用，有兴趣可以将整个流程进入更深层次代码解析，将助于我们对 containerd 整个架构各功能模块用途加深理解。 cmd&#x2F;ctr&#x2F;commands&#x2F;images&#x2F;pull.go:57 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869\tAction: func(context *cli.Context) error &#123; var ( ref = context.Args().First() ) // 命令输入 ref 检验 if ref == &quot;&quot; &#123; return fmt.Errorf(&quot;please provide an image reference to pull&quot;) &#125; // 创建 RPC client client, ctx, cancel, err := commands.NewClient(context) if err != nil &#123; return err &#125; defer cancel() ctx, done, err := client.WithLease(ctx) if err != nil &#123; return err &#125; defer done(ctx) // 构建拉取配置 config, err := content.NewFetchConfig(ctx, context) if err != nil &#123; return err &#125; // 拉取所有镜像内容存放至 content store,并将 image 元数据保存至 images store img, err := content.Fetch(ctx, client, ref, config) if err != nil &#123; return err &#125; log.G(ctx).WithField(&quot;image&quot;, ref).Debug(&quot;unpacking&quot;) // 平台类型解析 var p []ocispec.Platform if context.Bool(&quot;all-platforms&quot;) &#123; p, err = images.Platforms(ctx, client.ContentStore(), img.Target) if err != nil &#123; return errors.Wrap(err, &quot;unable to resolve image platforms&quot;) &#125; &#125; else &#123; for _, s := range context.StringSlice(&quot;platform&quot;) &#123; ps, err := platforms.Parse(s) if err != nil &#123; return errors.Wrapf(err, &quot;unable to parse platform %s&quot;, s) &#125; p = append(p, ps) &#125; &#125; if len(p) == 0 &#123; p = append(p, platforms.DefaultSpec()) &#125; // 解包镜像所有层内容( layers )到 snapshot 快照上(如 aufs 联合文件系统) for _, platform := range p &#123; fmt.Printf(&quot;unpacking %s %s... &quot;, platforms.Format(platform), img.Target.Digest) i := containerd.NewImageWithPlatform(client, img, platforms.Only(platform)) err = i.Unpack(ctx, context.String(&quot;snapshotter&quot;)) if err != nil &#123; return err &#125; &#125; fmt.Println(&quot;done&quot;) return nil\t&#125;,&#125; 附录ctr images 镜像管理子命令 123456789101112131415161718192021222324252627282930313233343536373839404142Name: &quot;list&quot;,Aliases: []string&#123;&quot;ls&quot;&#125;,Usage: &quot;list images known to containerd&quot;,Name: &quot;label&quot;,Usage: &quot;set and clear labels for an image&quot;,Name: &quot;check&quot;,Usage: &quot;check that an image has all content available locally&quot;,Name: &quot;remove&quot;,Aliases: []string&#123;&quot;rm&quot;&#125;,Usage: &quot;remove one or more images by reference&quot;,Name: &quot;import&quot;,Usage: &quot;import images&quot;,ArgsUsage: &quot;[flags] &lt;in&gt;&quot;,Description: `Import images from a tar stream.Name: &quot;export&quot;,Usage: &quot;export images&quot;,ArgsUsage: &quot;[flags] &lt;out&gt; &lt;image&gt; ...&quot;,Description: `Export images to an OCI tar archive.Name: &quot;pull&quot;,Usage: &quot;pull an image from a remote&quot;,ArgsUsage: &quot;[flags] &lt;ref&gt;&quot;,Description: `Fetch and prepare an image for use in containerd.Name: &quot;push&quot;,Usage: &quot;push an image to a remote&quot;,ArgsUsage: &quot;[flags] &lt;remote&gt; [&lt;local&gt;]&quot;,Description: `Pushes an image reference from containerd.Name: &quot;tag&quot;,Usage: &quot;tag an image&quot;,ArgsUsage: &quot;[flags] &lt;source_ref&gt; &lt;target_ref&gt; [&lt;target_ref&gt;, ...]&quot;,Description: `Tag an image for use in containerd.`, ~~ 本文 END 〜〜","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","Containerd"]},{"title":"Containerd Diff 服务","path":"/2023/01/16/Containerd_Diff/","content":"概述本文主要为从代码层面分析 Containerd diff 服务模块的实现逻辑，如下图 containerd 架构图所示： Containerd diff 服务模块，实现了 diff 和 apply 两个主要的服务管理功能 : Diff 服务计算所提供的上层&#x2F;下层 mount 目录的差异，遵从 OCI 规范 Changesets (变化集)打包 tar diff 镜像层存储。 Apply 服务将所指定描述器( ocispec.Descriptor )的参照内容应用至指定的挂载目录。通常情况下，描述器指向一个 tar 格式的文件系统差异，此差异文件系统 tar 将被应用于挂载点的顶层。 简单点描述为 “ Diff 功能实现 diff layer 生成 , Apply 功能实现 diff layer 挂载 “。 Containerd 被设计为一个类似微服务的架构, 针对各个组件都提供了 gRPC 接口来进行访问。Containerd 各组件以插件机制来组织管理，本文 diff 的服务将从插件注册开始展开。 Diff 服务注册链关系上层 GRPC Plugin 注册 diff , 获取已注册 Diff 服务插件列表，返回 Diff RPC 服务实现类 service{} 对象 services&#x2F;diff&#x2F;service.go:29 123456789101112131415161718192021222324func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.GRPCPlugin, ID: &quot;diff&quot;, Requires: []plugin.Type&#123; plugin.ServicePlugin, &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; plugins, err := ic.GetByType(plugin.ServicePlugin) // 获取所有服务插件 if err != nil &#123; return nil, err &#125; p, ok := plugins[services.DiffService] // 获取 diff 服务插件 if !ok &#123; return nil, errors.New(&quot;diff service not found&quot;) &#125; i, err := p.Instance() // 返回 diff 服务插件 initFn 的实例化对象 if err != nil &#123; return nil, err &#125; return &amp;service&#123;local: i.(diffapi.DiffClient)&#125;, nil &#125;,\t&#125;)&#125; Service Plugin 服务插件 diff 服务注册，返回 Local{} 服务实现类对象 services&#x2F;diff&#x2F;local.go:49 1234567891011121314151617181920212223242526272829303132333435363738func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.ServicePlugin, ID: services.DiffService, Requires: []plugin.Type&#123; plugin.DiffPlugin, &#125;, Config: defaultDifferConfig, // unix 默认 Order: []string&#123;&quot;walking&quot;&#125; InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; differs, err := ic.GetByType(plugin.DiffPlugin) if err != nil &#123; return nil, err &#125; orderedNames := ic.Config.(*config).Order ordered := make([]differ, len(orderedNames)) for i, n := range orderedNames &#123; differp, ok := differs[n] if !ok &#123; return nil, errors.Errorf(&quot;needed differ not loaded: %s&quot;, n) &#125; d, err := differp.Instance() if err != nil &#123; return nil, errors.Wrapf(err, &quot;could not load required differ due plugin init error: %s&quot;, n) &#125; ordered[i], ok = d.(differ) if !ok &#123; return nil, errors.Errorf(&quot;differ does not implement Comparer and Applier interface: %s&quot;, n) &#125; &#125; return &amp;local&#123; // 返回服务实现类 local&#123;&#125; 实例,即上层 RPC 注册时 p.Instance() differs: ordered, // 指定了 differs 对象列表，底层实现 differ 接口方法 （walking） &#125;, nil &#125;,\t&#125;)&#125; 底层实现类插件 Diff Plugin 注册 “walking” , 返回实例 diffPlugin{} 实现类对象 diff&#x2F;walking&#x2F;plugin&#x2F;plugin.go:28 123456789101112131415161718192021222324func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.DiffPlugin, ID: &quot;walking&quot;, Requires: []plugin.Type&#123; plugin.MetadataPlugin, &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; md, err := ic.Get(plugin.MetadataPlugin) if err != nil &#123; return nil, err &#125; ic.Meta.Platforms = append(ic.Meta.Platforms, platforms.DefaultSpec()) // 创建 metadata.DB 类型内容存储库，作为后面插件传入参数，用于保存 diff layer 元数据项。 cs := md.(*metadata.DB).ContentStore() return diffPlugin&#123; Comparer: walking.NewWalkingDiff(cs), // 差异比对器操作对象 Applier: apply.NewFileSystemApplier(cs), // 文件系统应用器操作对象 &#125;, nil &#125;,\t&#125;)&#125; Diff gRPC Service 和 local diff 实现前面 diff 服务插件注册时返回为 local{} 类对象，与此同时 diff 服务提供了下面两个方法 Apply() 、Diff()。而 service.local 属性为 diffapi.DiffClient 类型，代表diff client GRPC 请求来实现功能调用。而 diff 服务插件的注册时返回的实现了 diff 服务的类对象则是 local{} ，所有 s.local.Diff 的调用即是 local 类的 Diff 方法。此处应该注意 s.local 的 local 是一个 client 接口，而实现类也是一个同名的 local 类。 services&#x2F;diff&#x2F;service.go:65 1234567func (s *service) Apply(ctx context.Context, er *diffapi.ApplyRequest) (*diffapi.ApplyResponse, error) &#123;\treturn s.local.Apply(ctx, er) // RPC 请求 &quot;/containerd.services.diff.v1.Diff/Apply&quot;&#125;func (s *service) Diff(ctx context.Context, dr *diffapi.DiffRequest) (*diffapi.DiffResponse, error) &#123;\treturn s.local.Diff(ctx, dr) // RPC 请求 &quot;/containerd.services.diff.v1.Diff/Diff&quot;&#125; local.Apply services&#x2F;diff&#x2F;local.go:94 12345678910111213141516171819202122232425262728293031func (l *local) Apply(ctx context.Context, er *diffapi.ApplyRequest, _ ...grpc.CallOption) (*diffapi.ApplyResponse, error) &#123;\tvar ( ocidesc ocispec.Descriptor err error desc = toDescriptor(er.Diff) mounts = toMounts(er.Mounts)\t)\tvar opts []diff.ApplyOpt\tif er.Payloads != nil &#123; opts = append(opts, diff.WithPayloads(er.Payloads))\t&#125; // differ 应用调用\tfor _, differ := range l.differs &#123; ocidesc, err = differ.Apply(ctx, desc, mounts, opts...) if !errdefs.IsNotImplemented(err) &#123; break &#125;\t&#125;\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125; // grpc响应,应用返回的 ocidesc.Descriptor return &amp;diffapi.ApplyResponse&#123; Applied: fromDescriptor(ocidesc),\t&#125;, nil&#125; local.Diff services&#x2F;diff&#x2F;local.go:124 12345678910111213141516171819202122232425262728293031323334353637func (l *local) Diff(ctx context.Context, dr *diffapi.DiffRequest, _ ...grpc.CallOption) (*diffapi.DiffResponse, error) &#123;\tvar ( ocidesc ocispec.Descriptor err error aMounts = toMounts(dr.Left) bMounts = toMounts(dr.Right)\t) // 参数配置\tvar opts []diff.Opt\tif dr.MediaType != &quot;&quot; &#123; opts = append(opts, diff.WithMediaType(dr.MediaType))\t&#125;\tif dr.Ref != &quot;&quot; &#123; opts = append(opts, diff.WithReference(dr.Ref))\t&#125;\tif dr.Labels != nil &#123; opts = append(opts, diff.WithLabels(dr.Labels))\t&#125; // differ 差异比较调用\tfor _, d := range l.differs &#123; ocidesc, err = d.Compare(ctx, aMounts, bMounts, opts...) if !errdefs.IsNotImplemented(err) &#123; break &#125;\t&#125;\tif err != nil &#123; return nil, errdefs.ToGRPC(err)\t&#125; // grpc响应,应用返回的 ocidesc.Descriptor return &amp;diffapi.DiffResponse&#123; Diff: fromDescriptor(ocidesc),\t&#125;, nil&#125; 我们可以看到上面的 gRPC 实现服务层 Local 调用 Apply 和 Diff , 最终会调用底层 diffPlugin 类实例化的两个属性值对象： walking.walkingDiff 和 apply.fsApplier ，下面将一一分解分析。 Comparer 接口和 walking 实现Diff 的差异比对器的相关接口与结构定义 diff&#x2F;diff.go:46 123456789// Comparer allows creation of filesystem diffs between mounts// Comparer 允许创建两个挂载点的文件系统差异type Comparer interface &#123; // Compare 计算两个挂载点的不同，返回计算差异 diff 的描述符。 // 参数opts (可选项): // ref 参照ID -- 可被用于定位所创建的 diff 的实际内容 // media 类型 -- 用于决定所创建实际内容的格式\tCompare(ctx context.Context, lower, upper []mount.Mount, opts ...Opt) (ocispec.Descriptor, error)&#125; diff&#x2F;diff.go:28 123456789101112131415// Opt 用于配置 diff 操作，通过 func 的方式来操作 diff configtype Opt func(*Config) error// Config is used to hold parameters needed for a diff operationtype Config struct &#123; // 生成的 diff 层的类型如：“application/vnd.oci.image.layer.v1.tar+gzip”\tMediaType string\t// 内容的上传参照\t// 默认为随机字符串\tReference string // 对生成的内容应用标签\tLabels map[string]string&#125; Walking.NewWalkingDiff(cs) 返回 walkingDiff ，此类对象实现了 diff.Comparer 接口。walkingDiff store 属性为内容存储 content.Store 。 diff&#x2F;walking&#x2F;differ.go:52 123456789func NewWalkingDiff(store content.Store) diff.Comparer &#123;\treturn &amp;walkingDiff&#123; store: store, // 内容存储 &#125;&#125;// 类结构定义type walkingDiff struct &#123;\tstore content.Store &#125; Compare() 基于指定的两个挂载目录创建 diff layer,并将其 diff 内容上传到内容存储库 walkingDiff Compare 方法实现： upper 上层为变化层挂载目录，lower 下层为基线层挂载目录，上&#x2F;下进行差异比对； 按照 OCI changesets layer 规范打包计算差异结果集 diff tar 并存储至content store(注意两块存储: content 和 content matedata )； 通过对目录路径对比、文件属性对比、文件内容字节对比来分析与计算变化类型； 变化类型主要包含：add 、modify 、delete 、unmodified。 diff&#x2F;walking&#x2F;differ.go:60 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121func (s *walkingDiff) Compare(ctx context.Context, lower, upper []mount.Mount, opts ...diff.Opt) (d ocispec.Descriptor, err error) &#123; // 根据 opts 设置 diff 操作 Config var config diff.Config\tfor _, opt := range opts &#123; if err := opt(&amp;config); err != nil &#123; return emptyDesc, err &#125;\t&#125; // 设置默认媒体类型\tif config.MediaType == &quot;&quot; &#123; config.MediaType = ocispec.MediaTypeImageLayerGzip //压缩镜像层类型\t&#125;\tvar isCompressed bool\tswitch config.MediaType &#123; // 类型判断与 isCompressed 压缩标识\tcase ocispec.MediaTypeImageLayer: // 非压缩镜像层类型\tcase ocispec.MediaTypeImageLayerGzip: isCompressed = true\tdefault: return emptyDesc, errors.Wrapf(errdefs.ErrNotImplemented, &quot;unsupported diff media type: %v&quot;, config.MediaType)\t&#125;\tvar ocidesc ocispec.Descriptor // 临时目录挂载上 和 下镜像层\tif err := mount.WithTempMount(ctx, lower, func(lowerRoot string) error &#123; return mount.WithTempMount(ctx, upper, func(upperRoot string) error &#123; var newReference bool if config.Reference == &quot;&quot; &#123; newReference = true config.Reference = uniqueRef() // 生成 ref 唯一值 &#125; // 获取 store.Writer cw, err := s.store.Writer(ctx, content.WithRef(config.Reference), content.WithDescriptor(ocispec.Descriptor&#123; MediaType: config.MediaType, // most contentstore implementations just ignore this &#125;)) if err != nil &#123; return errors.Wrap(err, &quot;failed to open writer&quot;) &#125; //... if !newReference &#123; if err = cw.Truncate(0); err != nil &#123; return err &#125; &#125; // 压缩类型镜像层处理写入 diff 内容数据 if isCompressed &#123; dgstr := digest.SHA256.Digester() // SHA256 算法摘要串生成器 var compressed io.WriteCloser // 压缩 Gzip compressed, err = compression.CompressStream(cw, compression.Gzip) if err != nil &#123; return errors.Wrap(err, &quot;failed to get compressed stream&quot;) &#125; // +计算差异并写入 diff 内容数据 tar err = archive.WriteDiff(ctx, io.MultiWriter(compressed, dgstr.Hash()), lowerRoot, upperRoot) compressed.Close() if err != nil &#123; return errors.Wrap(err, &quot;failed to write compressed diff&quot;) &#125; if config.Labels == nil &#123; config.Labels = map[string]string&#123;&#125; &#125; // 压缩标签，存入摘要字串 config.Labels[uncompressed] = dgstr.Digest().String() &#125; else &#123; // 非压缩类型 tar 镜像层处理写入 diff 内容数据 if err = archive.WriteDiff(ctx, cw, lowerRoot, upperRoot); err != nil &#123; return errors.Wrap(err, &quot;failed to write diff&quot;) &#125; &#125; // commit 标签选项的设置 var commitopts []content.Opt if config.Labels != nil &#123; commitopts = append(commitopts, content.WithLabels(config.Labels)) &#125; // 生成内容摘要值，并接交至内容元数据存储 dgst := cw.Digest() if err := cw.Commit(ctx, 0, dgst, commitopts...); err != nil &#123; if !errdefs.IsAlreadyExists(err) &#123; return errors.Wrap(err, &quot;failed to commit&quot;) &#125; &#125; // 获取 dgst 对应的内容存储 info 信息 info, err := s.store.Info(ctx, dgst) if err != nil &#123; return errors.Wrap(err, &quot;failed to get info from content store&quot;) &#125; if info.Labels == nil &#123; info.Labels = make(map[string]string) &#125; // 内容存储 dgst 存在但无压缩标签时，设置 info 压缩标签 if _, ok := info.Labels[uncompressed]; !ok &#123; info.Labels[uncompressed] = config.Labels[uncompressed] if _, err := s.store.Update(ctx, info, &quot;labels.&quot;+uncompressed); err != nil &#123; return errors.Wrap(err, &quot;error setting uncompressed label&quot;) &#125; &#125; // 返回 diff 内容数据的描述器 Descriptor ocidesc = ocispec.Descriptor&#123; MediaType: config.MediaType, Size: info.Size, Digest: info.Digest, &#125; return nil &#125;)\t&#125;); err != nil &#123; return emptyDesc, err\t&#125;\treturn ocidesc, nil&#125; WriteDiff 计算所提供的两个目录(a&#x2F;b)的差异并写入 tar 包数据流。fs.Changes() 遍历计算差异，回调函数HandleChange为 ChangeSets 差异集 tar 打包处理逻辑, 其所生成的 tar 使用 OCI 标准规范的的文件标记用于对删除的文件表示。删除的文件基于 AUFS whiteouts 规范以 “.wh.” 作为前缀扩充命名文件。详细规范可以参考官方 image-spec 或 image-spec 中文 archive&#x2F;tar.go:72 12345678func WriteDiff(ctx context.Context, w io.Writer, a, b string) error &#123;\tcw := newChangeWriter(w, b) // +创建变化 writer err := fs.Changes(ctx, a, b, cw.HandleChange)\tif err != nil &#123; return errors.Wrap(err, &quot;failed to create diff tar stream&quot;)\t&#125;\treturn cw.Close()&#125; archive&#x2F;tar.go:451 12345678910func newChangeWriter(w io.Writer, source string) *changeWriter &#123;\treturn &amp;changeWriter&#123; tw: tar.NewWriter(w), // 创建 Writer 写数据 source: source, // 变化目录 whiteoutT: time.Now(), inodeSrc: map[uint64]string&#123;&#125;, inodeRefs: map[uint64][]string&#123;&#125;, addedDirs: map[string]struct&#123;&#125;&#123;&#125;,\t&#125;&#125; Changes 计算调用给定的变化计算函数 func 为每个变化类型进行处理。’a’ 是指基线目录和 ‘b’ 是更改的目录。变化回调按路径名排顺序调用和应用。正因此顺序，下面是情况为正确的: 删除的目录树只为根目录创建一个更改目录已删除项。其余的更改是隐含的。 一个目录修改为文件将不会有删除子路径项的条目，通过父目录删除条目来暗指这些条目删除。 隐藏目录不会被特殊处理，每个文件从基本目录中删除将显示为删除。 将对具有时间戳的文件进行文件内容比较可能存在被截断情况。如果正在比较的任意一个文件存在有一个零值纳秒值，将比较每个字节差异。如果两个文件具有相同的秒值但不同纳秒值如果其中一个值为零，则文件将如果内容相同，则视为未更改。这种行为是为了说明打包处理期间对时间戳截断的引起。 vendor&#x2F;github.com&#x2F;containerd&#x2F;continuity&#x2F;fs&#x2F;diff.go:101 12345678910111213141516func Changes(ctx context.Context, a, b string, changeFn ChangeFunc) error &#123;\tif a == &quot;&quot; &#123; // 如果 &#x27;a&#x27; 基线目录为空，则直接以增加类型变化处理所有文件 logrus.Debugf(&quot;Using single walk diff for %s&quot;, b) return addDirChanges(ctx, changeFn, b) &#125; else if diffOptions := detectDirDiff(b, a); diffOptions != nil &#123; // 有配置 diffOptions,当前版本 detectDirDiff() 直接返回 nil ,可忽略此逻辑（TODO项） logrus.Debugf(&quot;Using single walk diff for %s from %s&quot;, diffOptions.diffDir, a) return diffDirChanges(ctx, changeFn, a, diffOptions)\t&#125; // 使用上/下双目录同时遍历与计算 diff logrus.Debugf(&quot;Using double walk diff for %s from %s&quot;, b, a)\treturn doubleWalkDiff(ctx, changeFn, a, b)&#125; HandleChange 处理逻辑 func ,作为 Changes 计算的输入参数，为每个改变类型进行处理。变化类型主要包含：add 、modify 、delete 、unmodified(未更改)、空。 针对删除类型处理方式为 whiteOut ,则对删除的文件或目录创建前缀 “.wh.”+原始名的 whiteOut 文件。其它类型将内容进行 tar 打包。 archive&#x2F;tar.go:462 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154func (cw *changeWriter) HandleChange(k fs.ChangeKind, p string, f os.FileInfo, err error) error &#123;\tif err != nil &#123; return err\t&#125;\tif k == fs.ChangeKindDelete &#123; // 变化类型为&quot;删除&quot; whiteOutDir := filepath.Dir(p) whiteOutBase := filepath.Base(p) // whiteOut 前缀 &quot;.wh.&quot; + 原始文件名 whiteOut := filepath.Join(whiteOutDir, whiteoutPrefix+whiteOutBase) hdr := &amp;tar.Header&#123; Typeflag: tar.TypeReg, Name: whiteOut[1:], Size: 0, ModTime: cw.whiteoutT, AccessTime: cw.whiteoutT, ChangeTime: cw.whiteoutT, &#125; // whiteOut 父级目录不为 root 目录则作为修改变化类型处理 if err := cw.includeParents(hdr); err != nil &#123; return err &#125; // tar 写入 whiteout Header if err := cw.tw.WriteHeader(hdr); err != nil &#123; return errors.Wrap(err, &quot;failed to write whiteout header&quot;) &#125;\t&#125; else &#123; // 其它变化类型 var ( link string err error source = filepath.Join(cw.source, p) ) switch &#123; case f.Mode()&amp;os.ModeSocket != 0: // 忽略 sockets 文件 return nil case f.Mode()&amp;os.ModeSymlink != 0: // 链接文件则获取链接的目标位置 if link, err = os.Readlink(source); err != nil &#123; return err &#125; &#125; // 创建一个部分填充的头，如果f为链接，将链接记录为链接目标。如果f为目录，则在名称后附加斜杠。 hdr, err := tar.FileInfoHeader(f, link) if err != nil &#123; return err &#125; // 设置 header 权限与模式位 hdr.Mode = int64(chmodTarEntry(os.FileMode(hdr.Mode))) name := p if strings.HasPrefix(name, string(filepath.Separator)) &#123; name, err = filepath.Rel(string(filepath.Separator), name) if err != nil &#123; return errors.Wrap(err, &quot;failed to make path relative&quot;) &#125; &#125; // 返回系统支持的 Name name, err = tarName(name) if err != nil &#123; return errors.Wrap(err, &quot;cannot canonicalize path&quot;) &#125; // suffix with &#x27;/&#x27; for directories if f.IsDir() &amp;&amp; !strings.HasSuffix(name, &quot;/&quot;) &#123; name += &quot;/&quot; &#125; // 设置 header Name hdr.Name = name if err := setHeaderForSpecialDevice(hdr, name, f); err != nil &#123; return errors.Wrap(err, &quot;failed to set device headers&quot;) &#125; // 链接处理 var additionalLinks []string inode, isHardlink := fs.GetLinkInfo(f) if isHardlink &#123; // 硬链接 // If the inode has a source, always link to it if source, ok := cw.inodeSrc[inode]; ok &#123; hdr.Typeflag = tar.TypeLink hdr.Linkname = source hdr.Size = 0 &#125; else &#123; if k == fs.ChangeKindUnmodified &#123; cw.inodeRefs[inode] = append(cw.inodeRefs[inode], name) return nil &#125; cw.inodeSrc[inode] = name additionalLinks = cw.inodeRefs[inode] delete(cw.inodeRefs, inode) &#125; &#125; else if k == fs.ChangeKindUnmodified &#123; // 无改变类型，直接返回 return nil &#125; // header 设置 security.capability if capability, err := getxattr(source, &quot;security.capability&quot;); err != nil &#123; return errors.Wrap(err, &quot;failed to get capabilities xattr&quot;) &#125; else if capability != nil &#123; if hdr.PAXRecords == nil &#123; hdr.PAXRecords = map[string]string&#123;&#125; &#125; hdr.PAXRecords[paxSchilyXattr+&quot;security.capability&quot;] = string(capability) &#125; if err := cw.includeParents(hdr); err != nil &#123; return err &#125; // tar 写入文件头 if err := cw.tw.WriteHeader(hdr); err != nil &#123; return errors.Wrap(err, &quot;failed to write file header&quot;) &#125; if hdr.Typeflag == tar.TypeReg &amp;&amp; hdr.Size &gt; 0 &#123; file, err := open(source) // 打开文件 if err != nil &#123; return errors.Wrapf(err, &quot;failed to open path: %v&quot;, source) &#125; defer file.Close() // tar 写入文件内容数据 n, err := copyBuffered(context.TODO(), cw.tw, file) if err != nil &#123; return errors.Wrap(err, &quot;failed to copy&quot;) &#125; if n != hdr.Size &#123; return errors.New(&quot;short write copying file&quot;) &#125; &#125; // 写入 tar header 附加链信息 if additionalLinks != nil &#123; source = hdr.Name for _, extra := range additionalLinks &#123; hdr.Name = extra hdr.Typeflag = tar.TypeLink hdr.Linkname = source hdr.Size = 0 if err := cw.includeParents(hdr); err != nil &#123; return err &#125; if err := cw.tw.WriteHeader(hdr); err != nil &#123; return errors.Wrap(err, &quot;failed to write file header&quot;) &#125; &#125; &#125;\t&#125;\treturn nil&#125; addDirChanges 直接以 “ add “ 增加类型变化处理所有文件 vendor&#x2F;github.com&#x2F;containerd&#x2F;continuity&#x2F;fs&#x2F;diff.go:114 12345678910111213141516171819202122func addDirChanges(ctx context.Context, changeFn ChangeFunc, root string) error &#123;\treturn filepath.Walk(root, func(path string, f os.FileInfo, err error) error &#123; if err != nil &#123; return err &#125; // Rebase path path, err = filepath.Rel(root, path) if err != nil &#123; return err &#125; path = filepath.Join(string(os.PathSeparator), path) // Skip root if path == string(os.PathSeparator) &#123; return nil &#125; return changeFn(ChangeKindAdd, path, f, nil) // 增加变化类型处理\t&#125;)&#125; doubleWalkDiff 遍历两个 A 、B 目录进行对比分析差异，并调用 changeFn 处理 vendor&#x2F;github.com&#x2F;containerd&#x2F;continuity&#x2F;fs&#x2F;diff.go:234 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// doubleWalkDiff walks both directories to create a difffunc doubleWalkDiff(ctx context.Context, changeFn ChangeFunc, a, b string) (err error) &#123;\tg, ctx := errgroup.WithContext(ctx)\tvar ( c1 = make(chan *currentPath) c2 = make(chan *currentPath) f1, f2 *currentPath rmdir string\t)\tg.Go(func() error &#123; defer close(c1) return pathWalk(ctx, a, c1) // 遍历 A 目录，写入 chan C1\t&#125;) g.Go(func() error &#123; defer close(c2) return pathWalk(ctx, b, c2) // 遍历 B 目录，写入 chan C2\t&#125;)\tg.Go(func() error &#123; for c1 != nil || c2 != nil &#123; //循环比对 if f1 == nil &amp;&amp; c1 != nil &#123; f1, err = nextPath(ctx, c1) if err != nil &#123; return err &#125; if f1 == nil &#123; c1 = nil &#125; &#125; if f2 == nil &amp;&amp; c2 != nil &#123; f2, err = nextPath(ctx, c2) if err != nil &#123; return err &#125; if f2 == nil &#123; c2 = nil &#125; &#125; if f1 == nil &amp;&amp; f2 == nil &#123; continue &#125; var f os.FileInfo k, p := pathChange(f1, f2) // +计算路径并返回变化类型 switch k &#123; case ChangeKindAdd: // 增加变化类型 if rmdir != &quot;&quot; &#123; rmdir = &quot;&quot; &#125; f = f2.f f2 = nil case ChangeKindDelete:// 删除变化类型 if rmdir != &quot;&quot; &amp;&amp; strings.HasPrefix(f1.path, rmdir) &#123; f1 = nil continue &#125; else if f1.f.IsDir() &#123; // 如果是目录则赋值 rmdir rmdir = f1.path + string(os.PathSeparator) &#125; else if rmdir != &quot;&quot; &#123; rmdir = &quot;&quot; &#125; f1 = nil case ChangeKindModify: // 修改变化类型 same, err := sameFile(f1, f2) // 计算两者文件是否有修改 if err != nil &#123; return err &#125; if f1.f.IsDir() &amp;&amp; !f2.f.IsDir() &#123; // 如果文件修改为目录，删除目录 rmdir = f1.path + string(os.PathSeparator) &#125; else if rmdir != &quot;&quot; &#123; rmdir = &quot;&quot; &#125; f = f2.f f1 = nil f2 = nil if same &#123; // 一致则为 Unmodified 未修改变化类型 if !isLinked(f) &#123; continue &#125; k = ChangeKindUnmodified &#125; &#125; // 调用 changeFn 处理变化 if err := changeFn(k, p, f, nil); err != nil &#123; return err &#125; &#125; return nil\t&#125;)\treturn g.Wait() &#125; pathChange() 计算路径是否改变 vendor&#x2F;github.com&#x2F;containerd&#x2F;continuity&#x2F;fs&#x2F;path.go:39 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960func pathChange(lower, upper *currentPath) (ChangeKind, string) &#123;\t// lower 不存在， upper 存在，则为 ADD 增加类型变化 if lower == nil &#123; if upper == nil &#123; panic(&quot;cannot compare nil paths&quot;) &#125; return ChangeKindAdd, upper.path\t&#125; // 上面反之则为 Delete 删除类型变化\tif upper == nil &#123; return ChangeKindDelete, lower.path\t&#125; // 都存在的两者目录的路径长度大小比较或路径字符大小逐一比较\tswitch i := directoryCompare(lower.path, upper.path); &#123;\tcase i &lt; 0: // upper 不存在，lower 存在 return ChangeKindDelete, lower.path\tcase i &gt; 0: // upper 存在，lower 不存在 return ChangeKindAdd, upper.path\tdefault: // 默认 return ChangeKindModify, upper.path\t&#125;&#125;func directoryCompare(a, b string) int &#123;\tl := len(a)\tif len(b) &lt; l &#123; l = len(b)\t&#125; // 路径字符逐一比较\tfor i := 0; i &lt; l; i++ &#123; c1, c2 := a[i], b[i] if c1 == filepath.Separator &#123; c1 = byte(0) &#125; if c2 == filepath.Separator &#123; c2 = byte(0) &#125; if c1 &lt; c2 &#123; return -1 &#125; if c1 &gt; c2 &#123; return +1 &#125;\t&#125; // 路径字符长度比较 if len(a) &lt; len(b) &#123; return -1\t&#125;\tif len(a) &gt; len(b) &#123; return +1\t&#125;\treturn 0&#125; sameFile 计算文件是否被修改。 vendor&#x2F;github.com&#x2F;containerd&#x2F;continuity&#x2F;fs&#x2F;path.go:91 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func sameFile(f1, f2 *currentPath) (bool, error) &#123; // fileStat 比较是否一致\tif os.SameFile(f1.f, f2.f) &#123; return true, nil\t&#125; // 系统 Stat 是否一致\tequalStat, err := compareSysStat(f1.f.Sys(), f2.f.Sys())\tif err != nil || !equalStat &#123; return equalStat, err\t&#125; // security.capability 是否一致\tif eq, err := compareCapabilities(f1.fullPath, f2.fullPath); err != nil || !eq &#123; return eq, err\t&#125; // 如果不是目录检测文件大小、修改时间、和内容\tif !f1.f.IsDir() &#123; if f1.f.Size() != f2.f.Size() &#123; // 文件大小 return false, nil &#125; t1 := f1.f.ModTime() t2 := f2.f.ModTime() if t1.Unix() != t2.Unix() &#123; // 修改时间比对 return false, nil &#125; // 纳秒值存在截断情况，进一步检测两者内容差异 if t1.Nanosecond() == 0 &amp;&amp; t2.Nanosecond() == 0 &#123; var eq bool // 链接类型比对链接目录是否一致 if (f1.f.Mode() &amp; os.ModeSymlink) == os.ModeSymlink &#123; eq, err = compareSymlinkTarget(f1.fullPath, f2.fullPath) &#125; else if f1.f.Size() &gt; 0 &#123; // 比对文件内容，两个文件内容每个字节进行对比是否存在差异 eq, err = compareFileContent(f1.fullPath, f2.fullPath) &#125; if err != nil || !eq &#123; return eq, err &#125; &#125; else if t1.Nanosecond() != t2.Nanosecond() &#123; return false, nil &#125;\t&#125;\treturn true, nil&#125; Applier 接口和 fsApplier 应用实现 Apply 将所指定描述器( ocispec.Descriptor )的参照内容应用至指定的挂载目录。 例如：通常情况下，描述器是一个 tar 格式的文件系统差异，此差异文件系统 tar 将被应用于挂载点的顶层。 OCI image-spec 规范对 Changesets (变化集)应用描述： 媒体类型为 “application&#x2F;vnd.oci.image.layer.v1.tar” 的变化集 layer 被应用不仅仅是解包 tar 文件 变化集 layer 应用需要重点考虑 whiteout 文件处理 在无 whiteout 文件的Changesets (变化集) 如同正常 tar 文件解包 应用 Changesets (变化集) 实体，如果目标路径文件已存在，则： 移除文件路径 基于变化集实体项内容与属性，重建文件路径 Applier 接口定义如下： diff&#x2F;diff.go:65 123type Applier interface &#123;\tApply(ctx context.Context, desc ocispec.Descriptor, mount []mount.Mount, opts ...ApplyOpt) (ocispec.Descriptor, error)&#125; fsApplier 是 Applier 接口的实现类，定义与对象构造如下，注意唯一参数 content.Provider 内容读取器 diff&#x2F;apply&#x2F;apply.go:37 12345678910func NewFileSystemApplier(cs content.Provider) diff.Applier &#123;\treturn &amp;fsApplier&#123; store: cs, // 内容读取器\t&#125;&#125;type fsApplier struct &#123;\tstore content.Provider &#125; fsApplier.Apply 实现 Applier 接口的 Apply 方法。Apply 将所指定摘要值关联的内容应用至指定的挂载目录，打包文件将被解包或解压缩释放。 diff&#x2F;apply&#x2F;apply.go:52 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667func (s *fsApplier) Apply(ctx context.Context, desc ocispec.Descriptor, mounts []mount.Mount, opts ...diff.ApplyOpt) (d ocispec.Descriptor, err error) &#123;\tt1 := time.Now() //... // apply 操作 opts 配置\tvar config diff.ApplyConfig\tfor _, o := range opts &#123; if err := o(ctx, desc, &amp;config); err != nil &#123; return emptyDesc, errors.Wrap(err, &quot;failed to apply config opt&quot;) &#125;\t&#125; // 基于指定的 desc 描述符读取 content 内容 ra, err := s.store.ReaderAt(ctx, desc)\tif err != nil &#123; return emptyDesc, errors.Wrap(err, &quot;failed to get reader from content store&quot;)\t&#125;\tdefer ra.Close()\tvar processors []diff.StreamProcessor // 创建内容处理器\tprocessor := diff.NewProcessorChain(desc.MediaType, content.NewReader(ra))\tprocessors = append(processors, processor)\tfor &#123; // 获取 config 指定的类型内容处理器 if processor, err = diff.GetProcessor(ctx, processor, config.ProcessorPayloads); err != nil &#123; return emptyDesc, errors.Wrapf(err, &quot;failed to get stream processor for %s&quot;, desc.MediaType) &#125; processors = append(processors, processor) if processor.MediaType() == ocispec.MediaTypeImageLayer &#123; break &#125;\t&#125;\tdefer processor.Close() // 创建摘要生成器\tdigester := digest.Canonical.Digester() // 从 processor 读写入至 digester.Hash() ，返回 reader； // readCounter 包含读取器对象和读取大小统计\trc := &amp;readCounter&#123; r: io.TeeReader(processor, digester.Hash()),\t&#125; // +将内容应用至挂载目录上 if err := apply(ctx, mounts, rc); err != nil &#123; return emptyDesc, err\t&#125;\t// Read any trailing data\tif _, err := io.Copy(ioutil.Discard, rc); err != nil &#123; return emptyDesc, err\t&#125;\tfor _, p := range processors &#123; if ep, ok := p.(interface &#123; Err() error &#125;); ok &#123; if err := ep.Err(); err != nil &#123; return emptyDesc, err &#125; &#125;\t&#125; // 返回镜像层的 Descriptor\treturn ocispec.Descriptor&#123; MediaType: ocispec.MediaTypeImageLayer, Size: rc.c, Digest: digester.Digest(),\t&#125;, nil&#125; 此处理关注于 linux 系统版本和 aufs 挂载文件系统方式 apply 实现逻辑。此处 aufs 联合文件系统基础知识可以参考 diff&#x2F;apply&#x2F;apply_linux.go:32 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func apply(ctx context.Context, mounts []mount.Mount, r io.Reader) error &#123;\tswitch &#123; // overlay 文件系统； mounts 长度为1\tcase len(mounts) == 1 &amp;&amp; mounts[0].Type == &quot;overlay&quot;: path, parents, err := getOverlayPath(mounts[0].Options) if err != nil &#123; if errdefs.IsInvalidArgument(err) &#123; break &#125; return err &#125; opts := []archive.ApplyOpt&#123; archive.WithConvertWhiteout(archive.OverlayConvertWhiteout), &#125; if len(parents) &gt; 0 &#123; opts = append(opts, archive.WithParents(parents)) &#125; _, err = archive.Apply(ctx, path, r, opts...) return err // aufs 文件系统；mounts 长度为1\tcase len(mounts) == 1 &amp;&amp; mounts[0].Type == &quot;aufs&quot;: // 返回 mounts 的(上层 path )读写层和(下层 parents )只读层 path, parents, err := getAufsPath(mounts[0].Options) if err != nil &#123; if errdefs.IsInvalidArgument(err) &#123; break &#125; return err &#125; // 转化 whiteout 文件配置处理 func opts := []archive.ApplyOpt&#123; archive.WithConvertWhiteout(archive.AufsConvertWhiteout), &#125; if len(parents) &gt; 0 &#123; opts = append(opts, archive.WithParents(parents)) &#125; // +diff tar 数据流应用至一个目录 _, err = archive.Apply(ctx, path, r, opts...) return err\t&#125; // +other return mount.WithTempMount(ctx, mounts, func(root string) error &#123; _, err := archive.Apply(ctx, root, r) return err\t&#125;)&#125; 应用 OCI 规范的 diff tar 数据流, OCI 规范变化集应用详情可参考applying-changesets archive&#x2F;tar.go:101 1234567891011121314151617181920// Apply applies a tar stream of an OCI style diff tar.func Apply(ctx context.Context, root string, r io.Reader, opts ...ApplyOpt) (int64, error) &#123;\troot = filepath.Clean(root) // 应用选项配置\tvar options ApplyOptions\tfor _, opt := range opts &#123; if err := opt(&amp;options); err != nil &#123; return 0, errors.Wrap(err, &quot;failed to apply option&quot;) &#125;\t&#125;\tif options.Filter == nil &#123; options.Filter = all\t&#125;\tif options.applyFunc == nil &#123; options.applyFunc = applyNaive // 应用操作 func &#125; // +调用 applyFunc 为 applyNaive() return options.applyFunc(ctx, root, tar.NewReader(r), options)&#125; applyNaive 为原生 diff Apply 实现处理逻辑，将 OCI 规范 diff tar 数据流应用至一个目录上。 主要对 whiteout 文件进行删除处理 ，对其它文件进行 tar 解包并更新属性。 archive&#x2F;tar.go:123 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124func applyNaive(ctx context.Context, root string, tr *tar.Reader, options ApplyOptions) (size int64, err error) &#123;\tvar ( dirs []*tar.Header // Used for handling opaque directory markers which // may occur out of order unpackedPaths = make(map[string]struct&#123;&#125;) convertWhiteout = options.ConvertWhiteout\t) // 当为nil时, 定义 Whiteout 转化 func 实现\tif convertWhiteout == nil &#123; // convertWhiteout func , 通过删除目标文件作为 whiteouts 处理 convertWhiteout = func(hdr *tar.Header, path string) (bool, error) &#123; base := filepath.Base(path) dir := filepath.Dir(path) // 匹配 &quot;.wh..wh..opq&quot; ,处理隐式 whitout 目录 if base == whiteoutOpaqueDir &#123; _, err := os.Lstat(dir) if err != nil &#123; return false, err &#125; err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error &#123; if err != nil &#123; if os.IsNotExist(err) &#123; err = nil // parent was deleted &#125; return err &#125; if path == dir &#123; return nil &#125; if _, exists := unpackedPaths[path]; !exists &#123; err := os.RemoveAll(path) // 删除操作 return err &#125; return nil &#125;) return false, err &#125; // 匹配前缀 &#x27; .wh.* &#x27; if strings.HasPrefix(base, whiteoutPrefix) &#123; originalBase := base[len(whiteoutPrefix):] originalPath := filepath.Join(dir, originalBase) return false, os.RemoveAll(originalPath) // 删除操作 &#125; return true, nil &#125;\t&#125; // 迭代包内( tar.Reader )所有文件进行处理\tfor &#123; select &#123; case &lt;-ctx.Done(): return 0, ctx.Err() default: &#125; hdr, err := tr.Next() //下一个文件 //... // Split 根目录的名称并解析符号链接。 ppath, base := filepath.Split(hdr.Name) ppath, err = fs.RootPath(root, ppath) if err != nil &#123; return 0, errors.Wrap(err, &quot;failed to get root path&quot;) &#125; // 在连接到父路径之前连接到 root，以确保在添加到父路径之前已经基于根解析了相对链接。 path := filepath.Join(ppath, filepath.Join(&quot;/&quot;, base)) if path == root &#123; log.G(ctx).Debugf(&quot;file %q ignored: resolved to root&quot;, hdr.Name) continue &#125; // 如果文件不在根目录下，请确保父目录存在或已创建。 if ppath != root &#123; parentPath := ppath if base == &quot;&quot; &#123; parentPath = filepath.Dir(path) &#125; if err := mkparent(ctx, parentPath, root, options.Parents); err != nil &#123; return 0, err &#125; &#125; // 原生 whiteout 转化处理 func 实现是直接移除目标文件 if err := validateWhiteout(path); err != nil &#123; return 0, err &#125; writeFile, err := convertWhiteout(hdr, path) //... // 内容读取 reader srcData := io.Reader(tr) srcHdr := hdr // +创建 tar 文件 if err := createTarFile(ctx, path, root, srcHdr, srcData); err != nil &#123; return 0, err &#125; // 必须在最后处理目录 mtime，以避免在其中进一步创建文件来修改目录 mtime if hdr.Typeflag == tar.TypeDir &#123; dirs = append(dirs, hdr) &#125; unpackedPaths[path] = struct&#123;&#125;&#123;&#125;\t&#125;\tfor _, hdr := range dirs &#123; path, err := fs.RootPath(root, hdr.Name) if err != nil &#123; return 0, err &#125; if err := chtimes(path, boundTime(latestTime(hdr.AccessTime, hdr.ModTime)), boundTime(hdr.ModTime)); err != nil &#123; return 0, err &#125;\t&#125;\treturn size, nil&#125; createTarFile 创建与写入 tar 的内容文件及目录, 此方法为正常 tar 解包文件处理逻辑 archive&#x2F;tar.go:288 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586func createTarFile(ctx context.Context, path, extractDir string, hdr *tar.Header, reader io.Reader) error &#123;\thdrInfo := hdr.FileInfo() // 根据文件类型创建和写入内容\tswitch hdr.Typeflag &#123; case tar.TypeDir: // Dir // Create directory unless it exists as a directory already. // In that case we just want to merge the two if fi, err := os.Lstat(path); !(err == nil &amp;&amp; fi.IsDir()) &#123; if err := mkdir(path, hdrInfo.Mode()); err != nil &#123; return err &#125; &#125;\tcase tar.TypeReg, tar.TypeRegA: // Geg file, err := openFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, hdrInfo.Mode()) if err != nil &#123; return err &#125; _, err = copyBuffered(ctx, file, reader) if err1 := file.Close(); err == nil &#123; err = err1 &#125; if err != nil &#123; return err &#125;\tcase tar.TypeBlock, tar.TypeChar: // FIFO // Handle this is an OS-specific way if err := handleTarTypeBlockCharFifo(hdr, path); err != nil &#123; return err &#125;\tcase tar.TypeFifo: // FIFO // Handle this is an OS-specific way if err := handleTarTypeBlockCharFifo(hdr, path); err != nil &#123; return err &#125; case tar.TypeLink: // Hard Link targetPath, err := hardlinkRootPath(extractDir, hdr.Linkname) if err != nil &#123; return err &#125; if err := os.Link(targetPath, path); err != nil &#123; return err &#125;\tcase tar.TypeSymlink: // Symlink if err := os.Symlink(hdr.Linkname, path); err != nil &#123; return err &#125;\tcase tar.TypeXGlobalHeader: log.G(ctx).Debug(&quot;PAX Global Extended Headers found and ignored&quot;) return nil\tdefault: return errors.Errorf(&quot;unhandled tar header type %d &quot;, hdr.Typeflag)\t&#125; //... // xattr 属性设置 for key, value := range hdr.PAXRecords &#123; if strings.HasPrefix(key, paxSchilyXattr) &#123; key = key[len(paxSchilyXattr):] if err := setxattr(path, key, value); err != nil &#123; if errors.Cause(err) == syscall.ENOTSUP &#123; log.G(ctx).WithError(err).Warnf(&quot;ignored xattr %s in archive&quot;, key) continue &#125; return err &#125; &#125;\t&#125; // change owner 设置\tif err := handleLChmod(hdr, path, hdrInfo); err != nil &#123; return err\t&#125; // 创建时间\treturn chtimes(path, boundTime(latestTime(hdr.AccessTime, hdr.ModTime)), boundTime(hdr.ModTime))&#125; 再来看一下 mount.WithTempMount() 的实现，将所有挂载目录列表挂载到临时目录，然后将此临时目录作为传参给回调func f处理，我们可以从上面的代码了解到回调 func 内的处理也就是调用 archive.Apply() 处理，此apply 上面已详细的分析了代码逻辑。此处我们关注如何 mount 所有挂载目录的过程逻辑。 mount&#x2F;temp.go:33 1234567891011121314func WithTempMount(ctx context.Context, mounts []Mount, f func(root string) error) (err error) &#123; // 生成临时目录&quot;/containerd-mount&quot;\troot, uerr := ioutil.TempDir(tempMountLocation, &quot;containerd-mount&quot;)\tif uerr != nil &#123; return errors.Wrapf(uerr, &quot;failed to create temp dir&quot;)\t&#125; //... // 挂载所有到上面创建的临时目录\tif uerr = All(mounts, root); uerr != nil &#123; return errors.Wrapf(uerr, &quot;failed to mount %s&quot;, root)\t&#125; // 回调func f ,传参为挂载后的目录\treturn errors.Wrapf(f(root), &quot;mount callback failed on %s&quot;, root)&#125; All() 遍历挂载所有 mount 到指定的目标目录 mount&#x2F;mount.go:33 12345678func All(mounts []Mount, target string) error &#123;\tfor _, m := range mounts &#123; if err := m.Mount(target); err != nil &#123; // +遍历挂载 return err &#125;\t&#125;\treturn nil&#125; mount.Mount() 为 linux OS 底层对 mount 的调用实现 ，调用 unix.Mount() 来完成挂载操作。 mount&#x2F;mount_linux.go:38 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Mount to the provided target pathfunc (m *Mount) Mount(target string) error &#123;\tvar ( chdir string options = m.Options\t)\t// avoid hitting one page limit of mount argument buffer\t//\t// NOTE: 512 is a buffer during pagesize check.\tif m.Type == &quot;overlay&quot; &amp;&amp; optionsSize(options) &gt;= pagesize-512 &#123; chdir, options = compactLowerdirOption(options)\t&#125;\tflags, data := parseMountOptions(options)\tif len(data) &gt; pagesize &#123; return errors.Errorf(&quot;mount options is too long&quot;)\t&#125;\t// propagation types.\tconst ptypes = unix.MS_SHARED | unix.MS_PRIVATE | unix.MS_SLAVE | unix.MS_UNBINDABLE\t// Ensure propagation type change flags aren&#x27;t included in other calls.\toflags := flags &amp;^ ptypes\t// In the case of remounting with changed data (data != &quot;&quot;), need to call mount (moby/moby#34077).\tif flags&amp;unix.MS_REMOUNT == 0 || data != &quot;&quot; &#123; // Initial call applying all non-propagation flags for mount // or remount with changed data if err := mountAt(chdir, m.Source, target, m.Type, uintptr(oflags), data); err != nil &#123; return err &#125;\t&#125;\tif flags&amp;ptypes != 0 &#123; // Change the propagation type. const pflags = ptypes | unix.MS_REC | unix.MS_SILENT if err := unix.Mount(&quot;&quot;, target, &quot;&quot;, uintptr(flags&amp;pflags), &quot;&quot;); err != nil &#123; return err &#125;\t&#125;\tconst broflags = unix.MS_BIND | unix.MS_RDONLY\tif oflags&amp;broflags == broflags &#123; // Remount the bind to apply read only. return unix.Mount(&quot;&quot;, target, &quot;&quot;, uintptr(oflags|unix.MS_REMOUNT), &quot;&quot;)\t&#125;\treturn nil&#125; 前面已解析了 diff 服务( diff &#x2F; apply )的底层实现代码逻辑，我们再来看看上层的对 diff 应用实例的分析，加深对 diff 的应用场景的理解。下面给出了对 contained cli 工具 ctr 命令 snapshot diff 的代码分析。 Snapshot diff 应用ctr 工具的 snapshot diff 命令实现逻辑 cmd&#x2F;ctr&#x2F;commands&#x2F;snapshots&#x2F;snapshots.go:112 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768\tAction: func(context *cli.Context) error &#123; var ( idA = context.Args().First() idB = context.Args().Get(1) ) if idA == &quot;&quot; &#123; return errors.New(&quot;snapshot id must be provided&quot;) &#125; client, ctx, cancel, err := commands.NewClient(context) if err != nil &#123; return err &#125; defer cancel() ctx, done, err := client.WithLease(ctx) if err != nil &#123; return err &#125; defer done(ctx) var desc ocispec.Descriptor labels := commands.LabelArgs(context.StringSlice(&quot;label&quot;)) snapshotter := client.SnapshotService(context.GlobalString(&quot;snapshotter&quot;)) fmt.Println(context.String(&quot;media-type&quot;)) if context.Bool(&quot;keep&quot;) &#123; labels[&quot;containerd.io/gc.root&quot;] = time.Now().UTC().Format(time.RFC3339) &#125; opts := []diff.Opt&#123; diff.WithMediaType(context.String(&quot;media-type&quot;)), diff.WithReference(context.String(&quot;ref&quot;)), diff.WithLabels(labels), &#125; if idB == &quot;&quot; &#123; // 未指定参数 idB 则 CreateDiff 以“父”为比较对象求两者差异 desc, err = rootfs.CreateDiff(ctx, idA, snapshotter, client.DiffService(), opts...) if err != nil &#123; return err &#125; &#125; else &#123; // 指定参数 idB 则 Compare // 挂载快照 desc, err = withMounts(ctx, idA, snapshotter, func(a []mount.Mount) (ocispec.Descriptor, error) &#123; return withMounts(ctx, idB, snapshotter, func(b []mount.Mount) (ocispec.Descriptor, error) &#123; // DiffService Compare 调用进行比较 A/B 差异，返回 Descriptor return client.DiffService().Compare(ctx, a, b, opts...) &#125;) &#125;) if err != nil &#123; return err &#125; &#125; // 从内容存储库读取 desc 内容 ra, err := client.ContentStore().ReaderAt(ctx, desc) if err != nil &#123; return err &#125; // 标准输出内容 _, err = io.Copy(os.Stdout, content.NewReader(ra)) return err\t&#125;,&#125; rootfs.Creatediff() 从给定的快照的“父”与自身两者比较创建layer diff(镜像层差异)。 提供内容引用以跟踪内容创建的进度，提供的快照程序和挂载差异用于差异的计算，最后将返回layer diff(镜像层差异)的描述符。 rootfs&#x2F;diff.go:32 123456789101112131415161718192021222324252627282930func CreateDiff(ctx context.Context, snapshotID string, sn snapshots.Snapshotter, d diff.Comparer, opts ...diff.Opt) (ocispec.Descriptor, error) &#123;\tinfo, err := sn.Stat(ctx, snapshotID)\tif err != nil &#123; return ocispec.Descriptor&#123;&#125;, err\t&#125;\tlowerKey := fmt.Sprintf(&quot;%s-parent-view&quot;, info.Parent) // 指定的“父” key 引用\tlower, err := sn.View(ctx, lowerKey, info.Parent) // snapshotter.View if err != nil &#123; return ocispec.Descriptor&#123;&#125;, err\t&#125;\tdefer sn.Remove(ctx, lowerKey)\tvar upper []mount.Mount\tif info.Kind == snapshots.KindActive &#123; upper, err = sn.Mounts(ctx, snapshotID) if err != nil &#123; return ocispec.Descriptor&#123;&#125;, err &#125;\t&#125; else &#123; upperKey := fmt.Sprintf(&quot;%s-view&quot;, snapshotID) // 指定的 snapshot 引用 upper, err = sn.View(ctx, upperKey, snapshotID) if err != nil &#123; return ocispec.Descriptor&#123;&#125;, err &#125; defer sn.Remove(ctx, upperKey)\t&#125;\treturn d.Compare(ctx, lower, upper, opts...) // 比较两者差异并返回 layer diff Descriptor&#125; ~~ 本文 END ~~","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","Containerd"]},{"title":"Containerd Content 服务","path":"/2023/01/16/Containerd_Content/","content":"概述本文主要针对 Containerd content 服务功能模块的相关代码分析，如下图 Containerd 官方架构图所示: 如同 Containerd 其它服务功能模块化机制，本文将从Content 服务相关接口定义、GRPC 和 Service 插件化注册、Plugin 加载相关过程、最后到服务功能的底层实现逻辑进行逐步分析 。 content 服务的作用？ 定义： ref 唯一标识值 Content Store接口与方法定义Store 接口继承了各 content 内容管理相关的接口集合，后面每个接口将都有详细说明 content&#x2F;content.go:136 123456type Store interface &#123;\tManager // 信息查找、删除管理接口 Provider // 读取接口 IngestManager // 写管理接口(写状态、终止)\tIngester // 存写接口&#125; Manager 提供了基础的 content 内容管理方法如内容元信息获取、更新、列表查找、删除 content&#x2F;content.go:75 12345678910111213type Manager interface &#123; // 返回内容存储数据库存放 content 元数据信息\tInfo(ctx context.Context, dgst digest.Digest) (Info, error) // 更新 content 相关的可变信息项，如 labels.* 标签项更新\tUpdate(ctx context.Context, info Info, fieldpaths ...string) (Info, error) // 遍历内容存储数据库的所有项进行查找匹配指定的过滤条件项\tWalk(ctx context.Context, fn WalkFunc, filters ...string) error\t// 从内容存储数据库移除指定的 content\tDelete(ctx context.Context, dgst digest.Digest) error&#125; Provider 提供了 content 的读取接口，返回一个内容读取器对象 ReaderAt content&#x2F;content.go:35 1234567891011type Provider interface &#123;\t// ocispec.Descriptor 描述符唯一需要指定 desc.Digest 内容的摘要散列值 ReaderAt(ctx context.Context, dec ocispec.Descriptor) (ReaderAt, error)&#125;// 使用标准的 io 接口 io.Closer 、io.ReaderAt，扩展大小计算报告type ReaderAt interface &#123;\tio.ReaderAt\tio.Closer\tSize() int64&#125; IngestManager 写管理接口(存写状态获取、中止操作) content&#x2F;content.go:98 12345678910type IngestManager interface &#123;\t// 查看指定 ref 引用 Ingest 操作的状态信息\tStatus(ctx context.Context, ref string) (Status, error) // 列出所有活动的写操作与状态信息，可通过 filters 提供的正则表达式来过滤列出项 ListStatuses(ctx context.Context, filters ...string) ([]Status, error)\t// 取消操作\tAbort(ctx context.Context, ref string) error&#125; Ingester 提供了 content 的存写接口，返回一个内容写入器对象 Writer content&#x2F;content.go:44 1234type Ingester interface &#123;\t//Writer opts 需带指定 ref 来唯一标识活动\tWriter(ctx context.Context, opts ...WriterOpt) (Writer, error)&#125; Content GRPC 注册与 Server 实现content GRPC 插件注册，插件 InitFn 最后 contentserver.New(cs.(content.Store)) 返回 api.ContentServer，而GRPC 所依赖的服务插件 “content-service” 实例化对象作为其唯一传参,类型则是前面所详述的 content.Store 接口。 services&#x2F;content&#x2F;service.go:27 12345678910111213141516171819202122232425func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.GRPCPlugin, ID: &quot;content&quot;, Requires: []plugin.Type&#123; plugin.ServicePlugin, &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; plugins, err := ic.GetByType(plugin.ServicePlugin) //获取所有服务插件 if err != nil &#123; return nil, err &#125; p, ok := plugins[services.ContentService] // Key 为 &quot;content-service&quot; 服务插件 if !ok &#123; return nil, errors.New(&quot;content store service not found&quot;) &#125; cs, err := p.Instance() // &quot;content-service&quot; 插件实例化对象 if err != nil &#123; return nil, err &#125; // 传参 cs.(content.Store) return contentserver.New(cs.(content.Store)), nil &#125;,\t&#125;)&#125; ContentServer is the server API for Content service. api&#x2F;services&#x2F;content&#x2F;v1&#x2F;content.pb.go:1230 1234567891011type ContentServer interface &#123;\tInfo(context.Context, *InfoRequest) (*InfoResponse, error)\tUpdate(context.Context, *UpdateRequest) (*UpdateResponse, error)\tList(*ListContentRequest, Content_ListServer) error\tDelete(context.Context, *DeleteContentRequest) (*types.Empty, error)\tRead(*ReadContentRequest, Content_ReadServer) error\tStatus(context.Context, *StatusRequest) (*StatusResponse, error)\tListStatuses(context.Context, *ListStatusesRequest) (*ListStatusesResponse, error)\tWrite(Content_WriteServer) error\tAbort(context.Context, *AbortRequest) (*types.Empty, error)&#125; New returns the content GRPC server services&#x2F;content&#x2F;contentserver&#x2F;contentserver.go:50 123func New(cs content.Store) api.ContentServer &#123;\treturn &amp;service&#123;store: cs&#125; // service&#125; services&#x2F;content&#x2F;contentserver&#x2F;contentserver.go:38 123type service struct &#123;\tstore content.Store // content.Store 接口类型&#125; 上层Content Server 包装的 service 类实现了 api.ContentServer 接口，其主要功能是底层所注册的 “content-service” 插件的服务方法，如下读取 Read() 实现方法逻辑则主要调用了底层的 store.ReaderAt() 来实现 content 读取。其它剩余的方法(Info、Update、List、Delete、Status、ListStatuses、WriteAbort、Abort)实现也类似将不再一一展开。 services&#x2F;content&#x2F;contentserver&#x2F;contentserver.go:144 1234567891011121314151617181920func (s *service) Read(req *api.ReadContentRequest, session api.Content_ReadServer) error &#123;\tif err := req.Digest.Validate(); err != nil &#123; return status.Errorf(codes.InvalidArgument, &quot;%v: %v&quot;, req.Digest, err)\t&#125; // 调用底层服务方法 s.store.Info()\toi, err := s.store.Info(session.Context(), req.Digest)\tif err != nil &#123; return errdefs.ToGRPC(err)\t&#125; // 调用底层服务方法 s.store.ReaderAt() ra, err := s.store.ReaderAt(session.Context(), ocispec.Descriptor&#123;Digest: req.Digest&#125;)\tif err != nil &#123; return errdefs.ToGRPC(err)\t&#125; //...\treturn errdefs.ToGRPC(err)&#125; Content service 服务注册与实现注册 services&#x2F;content&#x2F;store.go:37 12345678910111213141516171819func init() &#123;\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.ServicePlugin, // 服务插件类型 ID: services.ContentService, // ID 为&quot;content-service&quot; Requires: []plugin.Type&#123; plugin.MetadataPlugin, // 依赖元数据插件 &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; m, err := ic.Get(plugin.MetadataPlugin) //获取元数据库注册的插件初始化对象 if err != nil &#123; return nil, err &#125; // +创建 content.Store 实例对象，其输入的参数为重点关注 // +m.(metadata.DB).ContentStore() 为元数据库指定的内容存储对象（后面详述） s, err := newContentStore(m.(*metadata.DB).ContentStore(), ic.Events) return s, err &#125;,\t&#125;)&#125; services&#x2F;content&#x2F;store.go:56 123456func newContentStore(cs content.Store, publisher events.Publisher) (content.Store, error) &#123;\treturn &amp;store&#123; Store: cs, // 内容存储对象 publisher: publisher,\t&#125;, nil&#125; store 类结构定义，实际上包装了 content.Store 增加事件的推送 services&#x2F;content&#x2F;store.go:32 1234type store struct &#123;\tcontent.Store\tpublisher events.Publisher&#125; 元数据库及内容存储库MetadataPlugin 元数据库在 containerd server 创建过程中对所有插件进行加载时被指定，同时指定了内容存储和snapshotter 实现类对象 services&#x2F;server&#x2F;server.go:304 123456789101112131415func LoadPlugins(ctx context.Context, config *srvconfig.Config) ([]*plugin.Registration, error) &#123;\t// load all plugins into containerd\tplugin.Register( //... plugin.Register(&amp;plugin.Registration&#123; Type: plugin.ContentPlugin, // 内容插件类型 ID: &quot;content&quot;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; ic.Meta.Exports[&quot;root&quot;] = ic.Root return local.NewStore(ic.Root) // 插件初始化func,创建与返回内容存储实例化对象 &#125;,\t&#125;) //...&#125; NewStore 本地内容存储构建，实际调用 NewLabeledStore ，返回 content.Store 接口实现类对象 store{root, ls} content&#x2F;local&#x2F;store.go:74 1234// NewStore returns a local content storefunc NewStore(root string) (content.Store, error) &#123;\treturn NewLabeledStore(root, nil)&#125; 12345678910func NewLabeledStore(root string, ls LabelStore) (content.Store, error) &#123;\tif err := os.MkdirAll(filepath.Join(root, &quot;ingest&quot;), 0777); err != nil &#123; return nil, err\t&#125;\treturn &amp;store&#123; root: root, ls: ls,\t&#125;, nil&#125; 下面我们将重点分析 content store 的实现类方法逻辑，本文主要分析 Writer 和 ReaderAt 两个方法，其它的方法可以查看源码。 store.Writer() 返回一个配置好的内容 writer 对象可供内容数据的写入 1234567891011121314151617181920212223242526// `ref` 参数用于为写事务生命周期管理的唯一标识，必须指定 reffunc (s *store) Writer(ctx context.Context, opts ...content.WriterOpt) (content.Writer, error) &#123;\tvar wOpts content.WriterOpts // 加载 writer 配置选项\tfor _, opt := range opts &#123; if err := opt(&amp;wOpts); err != nil &#123; return nil, err &#125;\t&#125; // ref 配置选项检查不能为空\tif wOpts.Ref == &quot;&quot; &#123; return nil, errors.Wrap(errdefs.ErrInvalidArgument, &quot;ref must not be empty&quot;)\t&#125; //... // +实标调用 writer()方法（下面详述）\tw, err := s.writer(ctx, wOpts.Ref, wOpts.Desc.Size, wOpts.Desc.Digest)\tif err != nil &#123; unlock(wOpts.Ref) return nil, err\t&#125;\treturn w, nil // lock is now held by w.&#125; content&#x2F;local&#x2F;store.go:511 ingest下的文档是为了实现下写入中断状态可恢复状态，但写入完成后将会清空相关数据文件 ingestPaths 基于 ref 定义生成数据处理的路径： path 为整个 ingest 的目录路径 $root&#x2F;ingest&#x2F;$digest(ref)&#x2F; refp 以 ref 为名文件路径 $root&#x2F;ingest&#x2F;$digest(ref)&#x2F;ref data 数据文件路径 $root&#x2F;ingest&#x2F;$digest(ref)&#x2F;data 1234567891011121314# sample└── ingest ├── 118362824418aca5274ffbd3a62eee91928022733f211c065e6b49bc280fc41c │ ├── data │ ├── ref │ ├── startedat │ ├── total │ └── updatedat └── 13a2d9c8635a9337aeda0bf3bb80d70b229d7fe19e41c750a28243008879de55 ├── data ├── ref ├── startedat ├── total └── updatedat 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596func (s *store) writer(ctx context.Context, ref string, total int64, expected digest.Digest) (content.Writer, error) &#123;\tif expected != &quot;&quot; &#123; // 通过摘要散列值生成 blob 文件对象路径 p := s.blobPath(expected) if _, err := os.Stat(p); err == nil &#123; return nil, errors.Wrapf(errdefs.ErrAlreadyExists, &quot;content %v&quot;, expected) &#125;\t&#125; // 基于 ref 定义生成数据处理的路径，返回三个路径： // path 为整个 ingest 的目录路径 $root/ingest/$digest(ref)/ // refp 以 ref 为名文件路径 $root/ingest/$digest(ref)/ref // data 数据文件路径 $root/ingest/$digest(ref)/data path, refp, data := s.ingestPaths(ref)\tvar ( digester = digest.Canonical.Digester() offset int64 startedAt time.Time updatedAt time.Time\t)\tfoundValidIngest := false // 确保 ingest 目录被创建\tif err := os.Mkdir(path, 0755); err != nil &#123; if !os.IsExist(err) &#123; return nil, err &#125; // 获取原 ref 及数据状态信息 status, err := s.resumeStatus(ref, total, digester) if err == nil &#123; foundValidIngest = true updatedAt = status.UpdatedAt startedAt = status.StartedAt total = status.Total offset = status.Offset &#125; else &#123; logrus.Infof(&quot;failed to resume the status from path %s: %s. will recreate them&quot;, path, err.Error()) &#125;\t&#125; // 如果不存在则创建相关文件\tif !foundValidIngest &#123; startedAt = time.Now() updatedAt = startedAt // ref 文件写入内容为 ref 指定的字符串信息 if err := ioutil.WriteFile(refp, []byte(ref), 0666); err != nil &#123; return nil, err &#125; // 开始时间 if err := writeTimestampFile(filepath.Join(path, &quot;startedat&quot;), startedAt); err != nil &#123; return nil, err &#125; // 更新时间 if err := writeTimestampFile(filepath.Join(path, &quot;updatedat&quot;), startedAt); err != nil &#123; return nil, err &#125; // 大小 if total &gt; 0 &#123; if err := ioutil.WriteFile(filepath.Join(path, &quot;total&quot;), []byte(fmt.Sprint(total)), 0666); err != nil &#123; return nil, err &#125; &#125;\t&#125; // 打开数据文件句柄\tfp, err := os.OpenFile(data, os.O_WRONLY|os.O_CREATE, 0666)\tif err != nil &#123; return nil, errors.Wrap(err, &quot;failed to open data file&quot;)\t&#125; // 定位偏移位置\tif _, err := fp.Seek(offset, io.SeekStart); err != nil &#123; return nil, errors.Wrap(err, &quot;could not seek to current write offset&quot;)\t&#125; // 最后返回一个 writer 对象\treturn &amp;writer&#123; s: s, fp: fp, ref: ref, path: path, offset: offset, total: total, digester: digester, startedAt: startedAt, updatedAt: updatedAt,\t&#125;, nil&#125; content&#x2F;local&#x2F;store.go:480 12345678910111213141516171819202122232425262728func (s *store) resumeStatus(ref string, total int64, digester digest.Digester) (content.Status, error) &#123;\tpath, _, data := s.ingestPaths(ref) // 基于 ref 定义生成数据处理的路径\tstatus, err := s.status(path) // 获取 ingest 目录的元状态信息\tif err != nil &#123; return status, errors.Wrap(err, &quot;failed reading status of resume write&quot;)\t&#125; // ref 值与 ingest 目录下检验是否一致\tif ref != status.Ref &#123; return status, errors.Wrapf(err, &quot;ref key does not match: %v != %v&quot;, ref, status.Ref)\t&#125; // 大小检验\tif total &gt; 0 &amp;&amp; status.Total &gt; 0 &amp;&amp; total != status.Total &#123; return status, errors.Errorf(&quot;provided total differs from status: %v != %v&quot;, total, status.Total)\t&#125;\t// 打开 blob 数据文件句柄\tfp, err := os.Open(data)\tif err != nil &#123; return status, err\t&#125;\tp := bufPool.Get().(*[]byte)\tstatus.Offset, err = io.CopyBuffer(digester.Hash(), fp, *p)\tbufPool.Put(p)\tfp.Close()\treturn status, err //返回状态信息&#125; store ReaderAt 返回 blob 的 io.ReaderAt ，其代码实现为标准的文件打开句柄加上文件大小。 ocispec.Descriptor OCI 标准格式描述符指定了需要读取的文件 blob 内容摘要散列值，通过在路径 $root&#x2F;blobs&#x2F;$digest 查找文件。 content&#x2F;local&#x2F;store.go:125 12345678910111213141516171819202122// ReaderAt returns an io.ReaderAt for the blob.func (s *store) ReaderAt(ctx context.Context, desc ocispec.Descriptor) (content.ReaderAt, error) &#123;\tp := s.blobPath(desc.Digest) // 通过指定的摘要散列值生成 blob 文件对象路径\tfi, err := os.Stat(p)\tif err != nil &#123; if !os.IsNotExist(err) &#123; return nil, err &#125; return nil, errors.Wrapf(errdefs.ErrNotFound, &quot;blob %s expected at %s&quot;, desc.Digest, p)\t&#125;\tfp, err := os.Open(p) // 打开文件获取文件句柄\tif err != nil &#123; if !os.IsNotExist(err) &#123; return nil, err &#125; return nil, errors.Wrapf(errdefs.ErrNotFound, &quot;blob %s expected at %s&quot;, desc.Digest, p)\t&#125;\treturn sizeReaderAt&#123;size: fi.Size(), fp: fp&#125;, nil &#125; 其它剩余的 content store 方法(Info、Update、List、Delete、Status、ListStatuses、WriteAbort、Abort)实现也类似,将不再一一展开。 附录ctr content 命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Name: &quot;get&quot;,Usage: &quot;get the data for an object&quot;,ArgsUsage: &quot;[&lt;digest&gt;, ...]&quot;,Description: &quot;display the image object&quot;,Name: &quot;ingest&quot;,Usage: &quot;accept content into the store&quot;,ArgsUsage: &quot;[flags] &lt;key&gt;&quot;,Description: &quot;ingest objects into the local content store&quot;,Name: &quot;active&quot;,Usage: &quot;display active transfers&quot;,ArgsUsage: &quot;[flags] [&lt;regexp&gt;]&quot;,Description: &quot;display the ongoing transfers&quot;,Name: &quot;list&quot;,Aliases: []string&#123;&quot;ls&quot;&#125;,Usage: &quot;list all blobs in the store&quot;,ArgsUsage: &quot;[flags]&quot;,Description: &quot;list blobs in the content store&quot;,Name: &quot;label&quot;,Usage: &quot;add labels to content&quot;,ArgsUsage: &quot;&lt;digest&gt; [&lt;label&gt;=&lt;value&gt; ...]&quot;,Description: &quot;labels blobs in the content store&quot;,Name: &quot;edit&quot;,Usage: &quot;edit a blob and return a new digest&quot;,ArgsUsage: &quot;[flags] &lt;digest&gt;&quot;,Description: &quot;edit a blob and return a new digest&quot;,Name: &quot;delete&quot;,Aliases: []string&#123;&quot;del&quot;, &quot;remove&quot;, &quot;rm&quot;&#125;,Usage: &quot;permanently delete one or more blobs&quot;,ArgsUsage: &quot;[&lt;digest&gt;, ...]&quot;,Description: `Delete one or more blobs permanently. Successfully deletedblobs are printed to stdout.`,Name: &quot;fetch-object&quot;,Usage: &quot;retrieve objects from a remote&quot;,ArgsUsage: &quot;[flags] &lt;remote&gt; &lt;object&gt; [&lt;hint&gt;, ...]&quot;,Description: `Fetch objects by identifier from a remote.`,Flags: commands.RegistryFlags,Name: &quot;push-object&quot;,Usage: &quot;push an object to a remote&quot;,ArgsUsage: &quot;[flags] &lt;remote&gt; &lt;object&gt; &lt;type&gt;&quot;,Description: `Push objects by identifier to a remote.`,Name: &quot;fetch&quot;,Usage: &quot;fetch all content for an image into containerd&quot;,ArgsUsage: &quot;[flags] &lt;remote&gt; &lt;object&gt;&quot;,Description: `Fetch an image into containerd. ~~ 本文 END ~~","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","Containerd"]},{"title":"Containerd 启动流程","path":"/2023/01/16/Containerd_bootstrap/","content":"概述Containerd 程序入口cmd&#x2F;containerd&#x2F;command&#x2F;main.go:68 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162// App returns a *cli.App instance.func App() *cli.App &#123;\tapp := cli.NewApp()\tapp.Name = &quot;containerd&quot;\tapp.Version = version.Version\tapp.Usage = usage\tapp.Flags = []cli.Flag&#123; cli.StringFlag&#123; Name: &quot;config,c&quot;, Usage: &quot;path to the configuration file&quot;, Value: defaultConfigPath, //默认配置位置 &#125;, cli.StringFlag&#123; Name: &quot;log-level,l&quot;, Usage: &quot;set the logging level [trace, debug, info, warn, error, fatal, panic]&quot;, &#125;, cli.StringFlag&#123; Name: &quot;address,a&quot;, Usage: &quot;address for containerd&#x27;s GRPC server&quot;, &#125;, cli.StringFlag&#123; Name: &quot;root&quot;, Usage: &quot;containerd root directory&quot;, &#125;, cli.StringFlag&#123; Name: &quot;state&quot;, Usage: &quot;containerd state directory&quot;, &#125;,\t&#125;\tapp.Flags = append(app.Flags, serviceFlags()...)\tapp.Commands = []cli.Command&#123; configCommand, publishCommand, ociHook,\t&#125;\tapp.Action = func(context *cli.Context) error &#123; var ( start = time.Now() signals = make(chan os.Signal, 2048) serverC = make(chan *server.Server, 1) ctx = gocontext.Background() config = defaultConfig() ) if err := srvconfig.LoadConfig(context.GlobalString(&quot;config&quot;), config); err != nil &amp;&amp; !os.IsNotExist(err) &#123; return err &#125; // Apply flags to the config if err := applyFlags(context, config); err != nil &#123; return err &#125; // Make sure top-level directories are created early. if err := server.CreateTopLevelDirectories(config); err != nil &#123; return err &#125; // Stop if we are registering or unregistering against Windows SCM. stop, err := registerUnregisterService(config.Root) if err != nil &#123; logrus.Fatal(err) &#125; if stop &#123; return nil &#125; done := handleSignals(ctx, signals, serverC) // start the signal handler as soon as we can to make sure that // we don&#x27;t miss any signals during boot signal.Notify(signals, handledSignals...) // 创建临时挂载点位置 &quot;$root/tmpmounts&quot; if err := mount.SetTempMountLocation(filepath.Join(config.Root, &quot;tmpmounts&quot;)); err != nil &#123; return errors.Wrap(err, &quot;creating temp mount location&quot;) &#125; // 通过 &quot;/proc/self/mountinfo&quot; 挂载信息后进行 unmount，在服务启动时清理挂载点 warnings, err := mount.CleanupTempMounts(0) if err != nil &#123; log.G(ctx).WithError(err).Error(&quot;unmounting temp mounts&quot;) &#125; for _, w := range warnings &#123; log.G(ctx).WithError(w).Warn(&quot;cleanup temp mount&quot;) &#125; var ( address = config.GRPC.Address // 全局 grpc 地址配置 ttrpcAddress = fmt.Sprintf(&quot;%s.ttrpc&quot;, config.GRPC.Address) ) // grpc 地址配置检测 if address == &quot;&quot; &#123; return errors.Wrap(errdefs.ErrInvalidArgument, &quot;grpc address cannot be empty&quot;) &#125; log.G(ctx).WithFields(logrus.Fields&#123; &quot;version&quot;: version.Version, &quot;revision&quot;: version.Revision, &#125;).Info(&quot;starting containerd&quot;) // +创建 containerd server 服务器对象 server, err := server.New(ctx, config) if err != nil &#123; return err &#125; // Launch as a Windows Service if necessary if err := launchService(server, done); err != nil &#123; logrus.Fatal(err) &#125; serverC &lt;- server // 配置与启动 Debug 服务 if config.Debug.Address != &quot;&quot; &#123; var l net.Listener if filepath.IsAbs(config.Debug.Address) &#123; if l, err = sys.GetLocalListener(config.Debug.Address, config.Debug.UID, config.Debug.GID); err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for debug endpoint&quot;) &#125; &#125; else &#123; if l, err = net.Listen(&quot;tcp&quot;, config.Debug.Address); err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for debug endpoint&quot;) &#125; &#125; serve(ctx, l, server.ServeDebug) &#125; // 配置与启动 Metrics 服务 if config.Metrics.Address != &quot;&quot; &#123; l, err := net.Listen(&quot;tcp&quot;, config.Metrics.Address) if err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for metrics endpoint&quot;) &#125; serve(ctx, l, server.ServeMetrics) &#125; // 配置与启动 ttrpc 端点服务 tl, err := sys.GetLocalListener(ttrpcAddress, config.GRPC.UID, config.GRPC.GID) if err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for main ttrpc endpoint&quot;) &#125; serve(ctx, tl, server.ServeTTRPC) if config.GRPC.TCPAddress != &quot;&quot; &#123; l, err := net.Listen(&quot;tcp&quot;, config.GRPC.TCPAddress) if err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for TCP grpc endpoint&quot;) &#125; serve(ctx, l, server.ServeTCP) &#125; // 配置与启动 grpc 端点服务 l, err := sys.GetLocalListener(address, config.GRPC.UID, config.GRPC.GID) if err != nil &#123; return errors.Wrapf(err, &quot;failed to get listener for main endpoint&quot;) &#125; serve(ctx, l, server.ServeGRPC) log.G(ctx).Infof(&quot;containerd successfully booted in %fs&quot;, time.Since(start).Seconds()) &lt;-done return nil\t&#125;\treturn app&#125; 加载默认配置 默认 root 根路径： “&#x2F;var&#x2F;lib&#x2F;containerd” 默认 state 运行状态路径 “&#x2F;run&#x2F;containerd” GRPC socket 路径：”&#x2F;run&#x2F;containerd&#x2F;containerd.sock” 1234567891011121314func defaultConfig() *srvconfig.Config &#123;\treturn &amp;srvconfig.Config&#123; Version: 1, Root: defaults.DefaultRootDir, State: defaults.DefaultStateDir, GRPC: srvconfig.GRPCConfig&#123; Address: defaults.DefaultAddress, MaxRecvMsgSize: defaults.DefaultMaxRecvMsgSize, MaxSendMsgSize: defaults.DefaultMaxSendMsgSize, &#125;, DisabledPlugins: []string&#123;&#125;, RequiredPlugins: []string&#123;&#125;,\t&#125;&#125; 自定义全局配置，可通过命令行 flags -config 或 -c 指定配置文件加载或直接特定的 flags 如 -root 则是修改根路径。 123456789// 加载外置的 config 文件为全局配置项if err := srvconfig.LoadConfig(context.GlobalString(&quot;config&quot;), config); err != nil &amp;&amp; !os.IsNotExist(err) &#123; return err &#125;// 通过 flags 加载全局配置项if err := applyFlags(context, config); err != nil &#123; return err&#125; 配置文件toml格式，引入解析库 123456789101112// LoadConfig loads the containerd server config from the provided pathfunc LoadConfig(path string, v *Config) error &#123;\tif v == nil &#123; return errors.Wrapf(errdefs.ErrInvalidArgument, &quot;argument v must not be nil&quot;)\t&#125;\tmd, err := toml.DecodeFile(path, v) // 解析外置 toml 配置文件\tif err != nil &#123; return err\t&#125;\tv.md = md\treturn v.ValidateV2()&#125; cmd&#x2F;containerd&#x2F;command&#x2F;main.go:243 1234567891011121314151617181920212223242526272829303132func applyFlags(context *cli.Context, config *srvconfig.Config) error &#123;\t// the order for config vs flag values is that flags will always override\t// the config values if they are set\tif err := setLevel(context, config); err != nil &#123; return err\t&#125;\tfor _, v := range []struct &#123; name string d *string\t&#125;&#123; &#123; name: &quot;root&quot;, d: &amp;config.Root, &#125;, &#123; name: &quot;state&quot;, d: &amp;config.State, &#125;, &#123; name: &quot;address&quot;, d: &amp;config.GRPC.Address, &#125;,\t&#125; &#123; if s := context.GlobalString(v.name); s != &quot;&quot; &#123; *v.d = s &#125;\t&#125;\tapplyPlatformFlags(context)\treturn nil&#125; 创建 Containerd Serverservices&#x2F;server&#x2F;server.go:77 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// New creates and initializes a new containerd serverfunc New(ctx context.Context, config *srvconfig.Config) (*Server, error) &#123;\tif err := apply(ctx, config); err != nil &#123; return nil, err\t&#125;\tfor key, sec := range config.Timeouts &#123; d, err := time.ParseDuration(sec) if err != nil &#123; return nil, errors.Errorf(&quot;unable to parse %s into a time duration&quot;, sec) &#125; timeout.Set(key, d)\t&#125;\tplugins, err := LoadPlugins(ctx, config)\tif err != nil &#123; return nil, err\t&#125;\tfor _, p := range config.StreamProcessors &#123; diff.RegisterProcessor(diff.BinaryHandler(p.ID, p.Returns, p.Accepts, p.Path, p.Args))\t&#125;\tserverOpts := []grpc.ServerOption&#123; grpc.UnaryInterceptor(grpc_prometheus.UnaryServerInterceptor), grpc.StreamInterceptor(grpc_prometheus.StreamServerInterceptor),\t&#125;\tif config.GRPC.MaxRecvMsgSize &gt; 0 &#123; serverOpts = append(serverOpts, grpc.MaxRecvMsgSize(config.GRPC.MaxRecvMsgSize))\t&#125;\tif config.GRPC.MaxSendMsgSize &gt; 0 &#123; serverOpts = append(serverOpts, grpc.MaxSendMsgSize(config.GRPC.MaxSendMsgSize))\t&#125;\tttrpcServer, err := newTTRPCServer()\tif err != nil &#123; return nil, err\t&#125;\ttcpServerOpts := serverOpts\tif config.GRPC.TCPTLSCert != &quot;&quot; &#123; log.G(ctx).Info(&quot;setting up tls on tcp GRPC services...&quot;) creds, err := credentials.NewServerTLSFromFile(config.GRPC.TCPTLSCert, config.GRPC.TCPTLSKey) if err != nil &#123; return nil, err &#125; tcpServerOpts = append(tcpServerOpts, grpc.Creds(creds))\t&#125;\tvar ( grpcServer = grpc.NewServer(serverOpts...) tcpServer = grpc.NewServer(tcpServerOpts...) grpcServices []plugin.Service tcpServices []plugin.TCPService ttrpcServices []plugin.TTRPCService s = &amp;Server&#123; grpcServer: grpcServer, tcpServer: tcpServer, ttrpcServer: ttrpcServer, events: exchange.NewExchange(), config: config, &#125; initialized = plugin.NewPluginSet() required = make(map[string]struct&#123;&#125;)\t)\tfor _, r := range config.RequiredPlugins &#123; required[r] = struct&#123;&#125;&#123;&#125;\t&#125;\tfor _, p := range plugins &#123; id := p.URI() reqID := id if config.GetVersion() == 1 &#123; reqID = p.ID &#125; log.G(ctx).WithField(&quot;type&quot;, p.Type).Infof(&quot;loading plugin %q...&quot;, id) initContext := plugin.NewContext( ctx, p, initialized, config.Root, config.State, ) initContext.Events = s.events initContext.Address = config.GRPC.Address // load the plugin specific configuration if it is provided if p.Config != nil &#123; pc, err := config.Decode(p) if err != nil &#123; return nil, err &#125; initContext.Config = pc &#125; result := p.Init(initContext) if err := initialized.Add(result); err != nil &#123; return nil, errors.Wrapf(err, &quot;could not add plugin result to plugin set&quot;) &#125; instance, err := result.Instance() if err != nil &#123; if plugin.IsSkipPlugin(err) &#123; log.G(ctx).WithError(err).WithField(&quot;type&quot;, p.Type).Infof(&quot;skip loading plugin %q...&quot;, id) &#125; else &#123; log.G(ctx).WithError(err).Warnf(&quot;failed to load plugin %s&quot;, id) &#125; if _, ok := required[reqID]; ok &#123; return nil, errors.Wrapf(err, &quot;load required plugin %s&quot;, id) &#125; continue &#125; delete(required, reqID) // check for grpc services that should be registered with the server if src, ok := instance.(plugin.Service); ok &#123; grpcServices = append(grpcServices, src) &#125; if src, ok := instance.(plugin.TTRPCService); ok &#123; ttrpcServices = append(ttrpcServices, src) &#125; if service, ok := instance.(plugin.TCPService); ok &#123; tcpServices = append(tcpServices, service) &#125; s.plugins = append(s.plugins, result)\t&#125;\tif len(required) != 0 &#123; var missing []string for id := range required &#123; missing = append(missing, id) &#125; return nil, errors.Errorf(&quot;required plugin %s not included&quot;, missing)\t&#125;\t// register services after all plugins have been initialized\tfor _, service := range grpcServices &#123; if err := service.Register(grpcServer); err != nil &#123; return nil, err &#125;\t&#125;\tfor _, service := range ttrpcServices &#123; if err := service.RegisterTTRPC(ttrpcServer); err != nil &#123; return nil, err &#125;\t&#125;\tfor _, service := range tcpServices &#123; if err := service.RegisterTCP(tcpServer); err != nil &#123; return nil, err &#125;\t&#125;\treturn s, nil&#125; 插件注册与加载LoadPlugins loads all plugins into containerd and generates an ordered graph of all plugins. services&#x2F;server&#x2F;server.go:304 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144func LoadPlugins(ctx context.Context, config *srvconfig.Config) ([]*plugin.Registration, error) &#123;\t// load all plugins into containerd\tpath := config.PluginDir\tif path == &quot;&quot; &#123; path = filepath.Join(config.Root, &quot;plugins&quot;) // 插件默认路径 /var/lib/containerd/plugins\t&#125;\tif err := plugin.Load(path); err != nil &#123; return nil, err\t&#125;\t// load additional plugins that don&#x27;t automatically register themselves\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.ContentPlugin, ID: &quot;content&quot;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; ic.Meta.Exports[&quot;root&quot;] = ic.Root return local.NewStore(ic.Root) &#125;,\t&#125;) // Metadata 插件注册\tplugin.Register(&amp;plugin.Registration&#123; Type: plugin.MetadataPlugin, ID: &quot;bolt&quot;, Requires: []plugin.Type&#123; plugin.ContentPlugin, plugin.SnapshotPlugin, &#125;, Config: &amp;srvconfig.BoltConfig&#123; ContentSharingPolicy: srvconfig.SharingPolicyShared, &#125;, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; if err := os.MkdirAll(ic.Root, 0711); err != nil &#123; return nil, err &#125; cs, err := ic.Get(plugin.ContentPlugin) if err != nil &#123; return nil, err &#125; snapshottersRaw, err := ic.GetByType(plugin.SnapshotPlugin) if err != nil &#123; return nil, err &#125; snapshotters := make(map[string]snapshots.Snapshotter) for name, sn := range snapshottersRaw &#123; sn, err := sn.Instance() if err != nil &#123; if !plugin.IsSkipPlugin(err) &#123; log.G(ic.Context).WithError(err). Warnf(&quot;could not use snapshotter %v in metadata plugin&quot;, name) &#125; continue &#125; snapshotters[name] = sn.(snapshots.Snapshotter) &#125; shared := true ic.Meta.Exports[&quot;policy&quot;] = srvconfig.SharingPolicyShared if cfg, ok := ic.Config.(*srvconfig.BoltConfig); ok &#123; if cfg.ContentSharingPolicy != &quot;&quot; &#123; if err := cfg.Validate(); err != nil &#123; return nil, err &#125; if cfg.ContentSharingPolicy == srvconfig.SharingPolicyIsolated &#123; ic.Meta.Exports[&quot;policy&quot;] = srvconfig.SharingPolicyIsolated shared = false &#125; log.L.WithField(&quot;policy&quot;, cfg.ContentSharingPolicy).Info(&quot;metadata content store policy set&quot;) &#125; &#125; path := filepath.Join(ic.Root, &quot;meta.db&quot;) //db文件存储路径 $Root/meta.db ic.Meta.Exports[&quot;path&quot;] = path db, err := bolt.Open(path, 0644, nil) //打开 bolt 连接 if err != nil &#123; return nil, err &#125; var dbopts []metadata.DBOpt if !shared &#123; dbopts = append(dbopts, metadata.WithPolicyIsolated) &#125; // 创建元数据库对象，关注三个关键的输入参数： // db为boltdb对象 // cs为内容存储对象 // snapshotters为快照管理器对象 mdb := metadata.NewDB(db, cs.(content.Store), snapshotters, dbopts...) if err := mdb.Init(ic.Context); err != nil &#123; return nil, err &#125; return mdb, nil &#125;,\t&#125;)\tclients := &amp;proxyClients&#123;&#125;\tfor name, pp := range config.ProxyPlugins &#123; var ( t plugin.Type f func(*grpc.ClientConn) interface&#123;&#125; address = pp.Address ) switch pp.Type &#123; case string(plugin.SnapshotPlugin), &quot;snapshot&quot;: t = plugin.SnapshotPlugin ssname := name f = func(conn *grpc.ClientConn) interface&#123;&#125; &#123; return ssproxy.NewSnapshotter(ssapi.NewSnapshotsClient(conn), ssname) &#125; case string(plugin.ContentPlugin), &quot;content&quot;: t = plugin.ContentPlugin f = func(conn *grpc.ClientConn) interface&#123;&#125; &#123; return csproxy.NewContentStore(csapi.NewContentClient(conn)) &#125; default: log.G(ctx).WithField(&quot;type&quot;, pp.Type).Warn(&quot;unknown proxy plugin type&quot;) &#125; plugin.Register(&amp;plugin.Registration&#123; Type: t, ID: name, InitFn: func(ic *plugin.InitContext) (interface&#123;&#125;, error) &#123; ic.Meta.Exports[&quot;address&quot;] = address conn, err := clients.getClient(address) if err != nil &#123; return nil, err &#125; return f(conn), nil &#125;, &#125;)\t&#125;\tfilter := srvconfig.V2DisabledFilter\tif config.GetVersion() == 1 &#123; filter = srvconfig.V1DisabledFilter\t&#125;\t// return the ordered graph for plugins\treturn plugin.Graph(filter(config.DisabledPlugins)), nil&#125;","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","Containerd"]},{"title":"OCI 镜像格式规范","path":"/2023/01/16/OCI_image_spec/","content":"概述参考： OCI 官网 OCI 镜像规范 OCI镜像规范定义一个镜像包含一个manifest、一个image index(可选)、一组文件系统layer和一个配置文件。 OCI 镜像规范的主要目的: 统一标准化容器镜像格式，让标准镜像能够在各容器软件下构建、传递及准备容器镜像运行。 Image 规范的高层组件包含: Image Manifest 清单文件是组成一个容器 image 的组件描述文档 Image Index (可选) 更高层的manifest文件，指向一组 manifests 和 descriptors 列表 Image Layout 镜像布局，表示一个镜像的内容布局 Filesystem Layer 描述一个容器文件系统的一个”变化集合” Image Configuration 配置文件包含如应用参数、环境等信息 Conversion 如何解析的描述文档 Descriptor 描述了类型、元数据和内容寻址的格式描述文件 Signatures (可选 ) 签名是基于签名的图像内容的地址 Naming (可选 ) 命名是联合基于DNS，可以授权 OCI Media Type 文件类型: Media Type 说明 application&#x2F;vnd.oci.descriptor.v1+json Content Descriptor 内容描述文件 application&#x2F;vnd.oci.layout.header.v1+json OCI Layout 布局描述文件 application&#x2F;vnd.oci.image.index.v1+json Image Index 高层次的镜像元信息文件 application&#x2F;vnd.oci.image.manifest.v1+json Image Manifest 镜像元信息文件 application&#x2F;vnd.oci.image.config.v1+json Image Config 镜像配置文件 application&#x2F;vnd.oci.image.layer.v1.tar Image Layer 镜像层文件 application&#x2F;vnd.oci.image.layer.v1.tar+gzip Image Layer 镜像层文件gzip压缩 application&#x2F;vnd.oci.image.layer.nondistributable.v1.tar Image Layer 非内容寻址管理 application&#x2F;vnd.oci.image.layer.nondistributable.v1.tar+gzip Image Layer, gzip压缩 非内容寻址管理 类型关系图 OCI Content DescriptorOCI 镜像由几部分组成，每个组件都是存储在一个目录结构中。每个组件之间都是通过内容寻址的方式互相引用。Content Descriptor 描述了一个目标内容的位置。Content Descriptor 包含：内容的类型、内容的标识符、内容的大小。Content Descriptor 必须通过嵌入到其他格式中使用。Content Descriptor 属性 mediaType string digest string size int64 urls array of strings annotations string-string map data string 保留字段 摘要和校验digest属性是Descriptor的核心，扮演了内容的标识符的角色。digest使用了防碰撞的哈希算法唯一的标识了内容。如果标识符能够以安全的获取。那么就算内容通过了不安全的来源获取，也能独立计算出标识符对内容的正确性进行确认。 digest的格式要求与示例：（sha256已经是一个广泛使用的Hash算法） 12345digest := algorithm &quot;:&quot; hexalgorithm := /[a-z0-9_+.-]+/hex := /[a-f0-9]+/sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b Content Descriptor 示例这个 Content Descriptor 描述了一个Manifest 12345&#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;, &quot;size&quot;: 7682, &quot;digest&quot;: &quot;sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270&quot;&#125; OCI Image Manifest 镜像清单格式规范参考 Manifest 的三大主要目标： 内容可寻址（通过 hash 算法为镜像和它的组件生成唯一ID） 支持多种平台的架构镜像（由一个更上层的 manifest 说明包含的镜像 manifests 其具体平台的版本情况） 能被解析成为 OCI 运行时规范 image manifest 包括一个 Image Config 和 一组 Image Layers 。 application/vnd.oci.image.manifest.v1+json 定义： 字段名 类型 必须 说明 schemaVersion int 必须 当前版本 mediaType string 保留 用于标识当前文件是什么类型的 config descriptor 必须 用于标识镜像的配置文件的位置application&#x2F;vnd.oci.image.config.v1+json layers array of descriptor 列表中的每一个成员都是一个镜像层，最底层的镜像在列表的第一项，其他各层按照堆叠顺序依次排列在后面。最终得到的文件系统应该和在一个空文件夹上堆叠各层得到的结果一样。用于堆叠的空文件夹的各种权限是不确定的。镜像层的mediaType，有比较多的选择： application&#x2F;vnd.oci.image.layer.v1.tarapplication&#x2F;vnd.oci.image.layer.v1.tar+gzipapplication&#x2F;vnd.oci.image.layer.nondistributable.v1.tarapplication&#x2F;vnd.oci.image.layer.nondistributable.v1.tar+gzip annotations string-string map 注释 manifest 示例: 1234567891011121314151617181920212223242526272829&#123; &quot;schemaVersion&quot;: 2, &quot;config&quot;: &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.config.v1+json&quot;, &quot;size&quot;: 7023, &quot;digest&quot;: &quot;sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7&quot; &#125;, &quot;layers&quot;: [ &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;, &quot;size&quot;: 32654, &quot;digest&quot;: &quot;sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f&quot; &#125;, &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;, &quot;size&quot;: 16724, &quot;digest&quot;: &quot;sha256:3c3a4604a545cdc127456d94e421cd355bca5b528f4a9c1905b15da2eb4a4c6b&quot; &#125;, &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;, &quot;size&quot;: 73109, &quot;digest&quot;: &quot;sha256:ec4b8955958665577945c89419d1af06b5f7636b4ac3da7f12184802ad867736&quot; &#125; ], &quot;annotations&quot;: &#123; &quot;com.example.key1&quot;: &quot;value1&quot;, &quot;com.example.key2&quot;: &quot;value2&quot; &#125;&#125; OCI Image Index 镜像索引格式规范参考 Image Index是一个更高层次的Manifest，一般在一个镜像需要提供多个平台支持时使用。 MediaType：application&#x2F;vnd.oci.image.index.v1+json 字段名 类型 必须 说明 schemaVersion int 必须 必须填2（为了兼容老版本的Docker) mediaType string 保留 用于标识当前文件是什么类型的 manifests array of objects 必须 给出了对于特定平台的Manifests列表 mediaType string Manifests string application&#x2F;vnd.oci.image.manifest.v1+json platform object 可选 描述了Manifest中描述的镜像是运行在哪一个指定的平台 architecture string 必须 指定了CPU的架构类型 os string 必须 指定了操作系统的类型 os.version string 可选 指定操作系统的版本要求 os.features array of strings 可选 指定了一些对于系统的特殊要求 variant string 可选 指定了CPU的版本要求 features array of strings 可选 指定了一些对于CPU指令集的特殊要求。（比如sse4、aes） annotations string-string map 注解 index 示例: 123456789101112131415161718192021222324252627282930&#123; &quot;schemaVersion&quot;: 2, &quot;manifests&quot;: [ &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;, &quot;size&quot;: 7143, &quot;digest&quot;: &quot;sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f&quot;, &quot;platform&quot;: &#123; &quot;architecture&quot;: &quot;ppc64le&quot;, &quot;os&quot;: &quot;linux&quot; &#125; &#125;, &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;, &quot;size&quot;: 7682, &quot;digest&quot;: &quot;sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270&quot;, &quot;platform&quot;: &#123; &quot;architecture&quot;: &quot;amd64&quot;, &quot;os&quot;: &quot;linux&quot;, &quot;os.features&quot;: [ &quot;sse4&quot; ] &#125; &#125; ], &quot;annotations&quot;: &#123; &quot;com.example.key1&quot;: &quot;value1&quot;, &quot;com.example.key2&quot;: &quot;value2&quot; &#125;&#125; OCI Image Layout 镜像布局规范参考 OCI的镜像布局是指内容寻址(blobs)和位置寻址(refs)的目录结构。这个布局可以使用多种方式传输：归档文件如tar&#x2F;zip、共享文件系统环境如nfs、网络传输如http&#x2F;ftp&#x2F;rsync等 镜像布局有以下部分组成： blobs directory 内容寻址的块文件，目录必须存在，但是可以为空。 oci-layout file 文件必须存在、必须是JSON格式,文件中必须包含一个imageLayoutVersion字段文件中可以有其他字段作为扩展使用 index.json file 文件必须存在、必须是JSON格式,文件中必须包含镜像Index的基本属性 示例 1234567$ cd example.com/app/$ find . -type f./index.json./oci-layout./blobs/sha256/3588d02542238316759cbf24502f4344ffcc8a60c803870022f335d1390c13b4./blobs/sha256/4b0bc1c4050b03c95ef2a8e36e25feac42fd31283e8c30b3ee5df6b043155d3c./blobs/sha256/7968321274dc6b6171697c33df7815310468e694ac5be0ec03ff053bb135e768 blob文件名命名是通过内容计算的shasum 12$ shasum -a 256 ./blobs/sha256/afff3924849e458c5ef237db5f89539274d5e609db5db935ed3959c90f1f2d51afff3924849e458c5ef237db5f89539274d5e609db5db935ed3959c90f1f2d51 ./blobs/sha256/afff3924849e458c5ef237db5f89539274d5e609db5db935ed3959c90f1f2d51 Index.json 文件 index.json 文件相当于整个镜像的入口。从这个文件可以获取整个镜像依赖到的所有文件的信息。 每一个在manifests 字段中的 descriptor 都指向一个 application&#x2F;vnd.oci.image.index.v1+json 或 application&#x2F;vnd.oci.image.manifest.v1+json 类型的文件。 一个通用的做法，org.opencontainers.image.ref.name 注解被认为是镜像 Tag 的含义。表示镜像的不同版本。 index.json 示例 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;schemaVersion&quot;: 2, &quot;manifests&quot;: [ &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.index.v1+json&quot;, &quot;size&quot;: 7143, &quot;digest&quot;: &quot;sha256:0228f90e926ba6b96e4f39cf294b2586d38fbb5a1e385c05cd1ee40ea54fe7fd&quot;, &quot;annotations&quot;: &#123; &quot;org.opencontainers.image.ref.name&quot;: &quot;stable-release&quot; &#125; &#125;, &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;, &quot;size&quot;: 7143, &quot;digest&quot;: &quot;sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f&quot;, &quot;platform&quot;: &#123; &quot;architecture&quot;: &quot;ppc64le&quot;, &quot;os&quot;: &quot;linux&quot; &#125;, &quot;annotations&quot;: &#123; &quot;org.opencontainers.image.ref.name&quot;: &quot;v1.0&quot; &#125; &#125;, &#123; &quot;mediaType&quot;: &quot;application/xml&quot;, &quot;size&quot;: 7143, &quot;digest&quot;: &quot;sha256:b3d63d132d21c3ff4c35a061adf23cf43da8ae054247e32faa95494d904a007e&quot;, &quot;annotations&quot;: &#123; &quot;org.freedesktop.specifications.metainfo.version&quot;: &quot;1.0&quot;, &quot;org.freedesktop.specifications.metainfo.type&quot;: &quot;AppStream&quot; &#125; &#125; ], &quot;annotations&quot;: &#123; &quot;com.example.index.revision&quot;: &quot;r124356&quot; &#125;&#125; OCI-layout 文件 在镜像规范中，这个文件特别简单，只有一个布局版本的字段。 oci-layout 示例 123&#123; &quot;imageLayoutVersion&quot;: &quot;1.0.0&quot;&#125; Blobs 文件夹 blobs文件夹下的子文件夹是以Hash算法的名称来命名的，这些子文件夹下包含了真正的实体文件。一个块被digest引用时（:，descriptor），这个块必须存放在blobs&#x2F;&#x2F;目录。blobs文件夹下面可能会存放很多已经没有任何引用的块文件。blobs文件夹下可以缺失一些被引用的块文件，只要被其他额外的块填满就可以了。 Blobs 示例 Image Index 1234567891011121314$ cat ./blobs/sha256/9b97579de92b1c195b85bb42a11011378ee549b02d7fe9c17bf2a6b35d5cb079 | jq&#123; &quot;schemaVersion&quot;: 2, &quot;manifests&quot;: [ &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.manifest.v1+json&quot;, &quot;size&quot;: 7143, &quot;digest&quot;: &quot;sha256:afff3924849e458c5ef237db5f89539274d5e609db5db935ed3959c90f1f2d51&quot;, &quot;platform&quot;: &#123; &quot;architecture&quot;: &quot;ppc64le&quot;, &quot;os&quot;: &quot;linux&quot; &#125; &#125;, ... Blobs 示例 Image Manifest 12345678910111213141516$ cat ./blobs/sha256/afff3924849e458c5ef237db5f89539274d5e609db5db935ed3959c90f1f2d51 | jq&#123; &quot;schemaVersion&quot;: 2, &quot;config&quot;: &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.config.v1+json&quot;, &quot;size&quot;: 7023, &quot;digest&quot;: &quot;sha256:5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270&quot; &#125;, &quot;layers&quot;: [ &#123; &quot;mediaType&quot;: &quot;application/vnd.oci.image.layer.v1.tar+gzip&quot;, &quot;size&quot;: 32654, &quot;digest&quot;: &quot;sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f&quot; &#125;, ... Blobs 示例 Image Config 1234567891011121314151617181920$ cat ./blobs/sha256/5b0bcabd1ed22e9fb1310cf6c2dec7cdef19f0ad69efa1f392e94a4333501270 | jq&#123; &quot;architecture&quot;: &quot;amd64&quot;, &quot;author&quot;: &quot;Alyssa P. Hacker &lt;alyspdev@example.com&gt;&quot;, &quot;config&quot;: &#123; &quot;Hostname&quot;: &quot;8dfe43d80430&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: null, &quot;Image&quot;: &quot;sha256:6986ae504bbf843512d680cc959484452034965db15f75ee8bdd1b107f61500b&quot;, ... Image Layer Blob 12$ cat ./blobs/sha256/e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f[tar stream] Image Layer Filesystem Changeset 镜像层规范参考 如何序列化 文件系统 以及 文件系统的改变(如删除文件) 到一个 blob 文件称之为” layer “，由一个或多个layer层叠加构成一个完整的文件系统。 Image Filesystem Changeset文件系统改变集 每一个layer都会有对它相对于父layer增、删、改的文件的一个存档，使用诸如AUFS等联合挂载文件系统，可以将一系列的image layer以单一的文件系统的形式呈现出来。 Change type 文件系统改变类型 123AdditionsModificationsRemovals 创建 Image Filesystem Changeset 创建根文件系统 根文件系统是基础或父 layer , 此处初始为空目录结构，使用唯一的目录名rootfs-c9d-v1 1rootfs-c9d-v1/ 创建初始文件与目录 123456rootfs-c9d-v1/ etc/ my-app-config bin/ my-app-binary my-app-tools ​ rootfs-c9d-v1 目录会被作为以下文件的打包存档的入口(tar) 123456././etc/./etc/my-app-config./bin/./bin/my-app-binary./bin/my-app-tools 复制或快照初始文件系统 以前面的根文件系统复制或快照，创建一个新的目录和初始化文件系统，目录名为rootfs-c9d-v1.s1 123456rootfs-c9d-v1.s1/ etc/ my-app-config bin/ my-app-binary my-app-tools 增加一个./etc/my-app.d目录包含default.cfg文件，删除存在的my-app-config文件。与此同时，改变./bin/my-app-tools二进制文件内容或属性。 1234567rootfs-c9d-v1.s1/ etc/ my-app.d/ default.cfg bin/ my-app-binary my-app-tools 检测变化和表示变化项 通过两个目录进行比较(“rootfs-c9d-v1” VS “rootfs-c9d-v1.s1”)，查询文件是否有被增加、修改、删除操作 1234Added: /etc/my-app.d/Added: /etc/my-app.d/default.cfgModified: /bin/my-app-toolsDeleted: /etc/my-app-config 创建 changeset 文件 打包 tar 文件仅包含 changeset : 增加与修改的文件和目录完整打包 删除的文件或目录由whiteout文件(.wh.命名)来标识 1234./etc/my-app.d/./etc/my-app.d/default.cfg./bin/my-app-tools./etc/.wh.my-app-config OCI Runtime Filesystem Bundle 运行时文件系统包参考 OCI Image 可通过镜像名称发现、下载、hash值来验证、签名受信以及解包成 OCI 运行时 Bundle。一个标准的容器 bundle 包含容器加载和运行所需的所有信息，其包含如下： config.json 容器配置数据文件，必须与文件系统同目录下，文件名必须为config.json root filesystem 容器 root 文件系统(启动的只读文件)，在 config.json 文件内有指定 root.path。 config.json 配置文件说明 config样例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372&#123; &quot;ociVersion&quot;: &quot;1.0.1&quot;, &quot;process&quot;: &#123; &quot;terminal&quot;: true, &quot;user&quot;: &#123; &quot;uid&quot;: 1, &quot;gid&quot;: 1, &quot;additionalGids&quot;: [ 5, 6 ] &#125;, &quot;args&quot;: [ &quot;sh&quot; ], &quot;env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;TERM=xterm&quot; ], &quot;cwd&quot;: &quot;/&quot;, &quot;capabilities&quot;: &#123; &quot;bounding&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot;, &quot;CAP_NET_BIND_SERVICE&quot; ], &quot;permitted&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot;, &quot;CAP_NET_BIND_SERVICE&quot; ], &quot;inheritable&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot;, &quot;CAP_NET_BIND_SERVICE&quot; ], &quot;effective&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot; ], &quot;ambient&quot;: [ &quot;CAP_NET_BIND_SERVICE&quot; ] &#125;, &quot;rlimits&quot;: [ &#123; &quot;type&quot;: &quot;RLIMIT_CORE&quot;, &quot;hard&quot;: 1024, &quot;soft&quot;: 1024 &#125;, &#123; &quot;type&quot;: &quot;RLIMIT_NOFILE&quot;, &quot;hard&quot;: 1024, &quot;soft&quot;: 1024 &#125; ], &quot;apparmorProfile&quot;: &quot;acme_secure_profile&quot;, &quot;oomScoreAdj&quot;: 100, &quot;selinuxLabel&quot;: &quot;system_u:system_r:svirt_lxc_net_t:s0:c124,c675&quot;, &quot;noNewPrivileges&quot;: true &#125;, &quot;root&quot;: &#123; &quot;path&quot;: &quot;rootfs&quot;, &quot;readonly&quot;: true &#125;, &quot;hostname&quot;: &quot;slartibartfast&quot;, &quot;mounts&quot;: [ &#123; &quot;destination&quot;: &quot;/proc&quot;, &quot;type&quot;: &quot;proc&quot;, &quot;source&quot;: &quot;proc&quot; &#125;, &#123; &quot;destination&quot;: &quot;/dev&quot;, &quot;type&quot;: &quot;tmpfs&quot;, &quot;source&quot;: &quot;tmpfs&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;strictatime&quot;, &quot;mode=755&quot;, &quot;size=65536k&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/pts&quot;, &quot;type&quot;: &quot;devpts&quot;, &quot;source&quot;: &quot;devpts&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;newinstance&quot;, &quot;ptmxmode=0666&quot;, &quot;mode=0620&quot;, &quot;gid=5&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/shm&quot;, &quot;type&quot;: &quot;tmpfs&quot;, &quot;source&quot;: &quot;shm&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot;, &quot;mode=1777&quot;, &quot;size=65536k&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/mqueue&quot;, &quot;type&quot;: &quot;mqueue&quot;, &quot;source&quot;: &quot;mqueue&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/sys&quot;, &quot;type&quot;: &quot;sysfs&quot;, &quot;source&quot;: &quot;sysfs&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/sys/fs/cgroup&quot;, &quot;type&quot;: &quot;cgroup&quot;, &quot;source&quot;: &quot;cgroup&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot;, &quot;relatime&quot;, &quot;ro&quot; ] &#125; ], &quot;hooks&quot;: &#123; &quot;prestart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/fix-mounts&quot;, &quot;args&quot;: [ &quot;fix-mounts&quot;, &quot;arg1&quot;, &quot;arg2&quot; ], &quot;env&quot;: [ &quot;key1=value1&quot; ] &#125;, &#123; &quot;path&quot;: &quot;/usr/bin/setup-network&quot; &#125; ], &quot;poststart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/notify-start&quot;, &quot;timeout&quot;: 5 &#125; ], &quot;poststop&quot;: [ &#123; &quot;path&quot;: &quot;/usr/sbin/cleanup.sh&quot;, &quot;args&quot;: [ &quot;cleanup.sh&quot;, &quot;-f&quot; ] &#125; ] &#125;, &quot;linux&quot;: &#123; &quot;devices&quot;: [ &#123; &quot;path&quot;: &quot;/dev/fuse&quot;, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;fileMode&quot;: 438, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125;, &#123; &quot;path&quot;: &quot;/dev/sda&quot;, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;fileMode&quot;: 432, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125; ], &quot;uidMappings&quot;: [ &#123; &quot;containerID&quot;: 0, &quot;hostID&quot;: 1000, &quot;size&quot;: 32000 &#125; ], &quot;gidMappings&quot;: [ &#123; &quot;containerID&quot;: 0, &quot;hostID&quot;: 1000, &quot;size&quot;: 32000 &#125; ], &quot;sysctl&quot;: &#123; &quot;net.ipv4.ip_forward&quot;: &quot;1&quot;, &quot;net.core.somaxconn&quot;: &quot;256&quot; &#125;, &quot;cgroupsPath&quot;: &quot;/myRuntime/myContainer&quot;, &quot;resources&quot;: &#123; &quot;network&quot;: &#123; &quot;classID&quot;: 1048577, &quot;priorities&quot;: [ &#123; &quot;name&quot;: &quot;eth0&quot;, &quot;priority&quot;: 500 &#125;, &#123; &quot;name&quot;: &quot;eth1&quot;, &quot;priority&quot;: 1000 &#125; ] &#125;, &quot;pids&quot;: &#123; &quot;limit&quot;: 32771 &#125;, &quot;hugepageLimits&quot;: [ &#123; &quot;pageSize&quot;: &quot;2MB&quot;, &quot;limit&quot;: 9223372036854772000 &#125;, &#123; &quot;pageSize&quot;: &quot;64KB&quot;, &quot;limit&quot;: 1000000 &#125; ], &quot;memory&quot;: &#123; &quot;limit&quot;: 536870912, &quot;reservation&quot;: 536870912, &quot;swap&quot;: 536870912, &quot;kernel&quot;: -1, &quot;kernelTCP&quot;: -1, &quot;swappiness&quot;: 0, &quot;disableOOMKiller&quot;: false &#125;, &quot;cpu&quot;: &#123; &quot;shares&quot;: 1024, &quot;quota&quot;: 1000000, &quot;period&quot;: 500000, &quot;realtimeRuntime&quot;: 950000, &quot;realtimePeriod&quot;: 1000000, &quot;cpus&quot;: &quot;2-3&quot;, &quot;mems&quot;: &quot;0-7&quot; &#125;, &quot;devices&quot;: [ &#123; &quot;allow&quot;: false, &quot;access&quot;: &quot;rwm&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;access&quot;: &quot;rw&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;access&quot;: &quot;r&quot; &#125; ], &quot;blockIO&quot;: &#123; &quot;weight&quot;: 10, &quot;leafWeight&quot;: 10, &quot;weightDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;weight&quot;: 500, &quot;leafWeight&quot;: 300 &#125;, &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;weight&quot;: 500 &#125; ], &quot;throttleReadBpsDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;rate&quot;: 600 &#125; ], &quot;throttleWriteIOPSDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;rate&quot;: 300 &#125; ] &#125; &#125;, &quot;rootfsPropagation&quot;: &quot;slave&quot;, &quot;seccomp&quot;: &#123; &quot;defaultAction&quot;: &quot;SCMP_ACT_ALLOW&quot;, &quot;architectures&quot;: [ &quot;SCMP_ARCH_X86&quot;, &quot;SCMP_ARCH_X32&quot; ], &quot;syscalls&quot;: [ &#123; &quot;names&quot;: [ &quot;getcwd&quot;, &quot;chmod&quot; ], &quot;action&quot;: &quot;SCMP_ACT_ERRNO&quot; &#125; ] &#125;, &quot;namespaces&quot;: [ &#123; &quot;type&quot;: &quot;pid&quot; &#125;, &#123; &quot;type&quot;: &quot;network&quot; &#125;, &#123; &quot;type&quot;: &quot;ipc&quot; &#125;, &#123; &quot;type&quot;: &quot;uts&quot; &#125;, &#123; &quot;type&quot;: &quot;mount&quot; &#125;, &#123; &quot;type&quot;: &quot;user&quot; &#125;, &#123; &quot;type&quot;: &quot;cgroup&quot; &#125; ], &quot;maskedPaths&quot;: [ &quot;/proc/kcore&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot; ], &quot;readonlyPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ], &quot;mountLabel&quot;: &quot;system_u:object_r:svirt_sandbox_file_t:s0:c715,c811&quot; &#125;, &quot;annotations&quot;: &#123; &quot;com.example.key1&quot;: &quot;value1&quot;, &quot;com.example.key2&quot;: &quot;value2&quot; &#125;&#125; ~~ 本文 END ~~","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","OCI"]},{"title":"OCI Runtime spec 运行时规范","path":"/2023/01/16/OCI_Runtime_spec/","content":"一 概述参考 **OCI 运行时规范目的是为了标准化一个容器的配置、执行环境、生命周期管理**。容器的配置文件由名为 config.json 文件内指定，配置文件内容提供所支持系统平台和创建一个容器所需的详细信息。执行环境是为了确保在容器内运行的应用程序与运行时具备的一致的环境，以及为容器的生命周期管理定义的了标准的公共操作。 容器原则 参考 OCI 定义软件交付的最小单元称之为”标准容器”，标准容器是为了按自描述性和可移值性的格式封装应用程序及其依赖的所有组件，实现任何遵从规范的运行时再无需额外依赖的运行，以及与底层机器设备和容器内部内容都无关。 标准容器的5个原则： 标准操作 内容无关 基础设施无关 为自动化设计 工业级交付 二 容器文件系统包参考 OCI Image 可通过镜像名称发现、下载、hash值来验证、签名受信以及解包成 OCI 运行时 Bundle。一个标准的容器 bundle 包含容器加载和运行所有所需的信息，其包含如下： config.json 容器配置数据文件，必须与文件系统同目录下，文件名必须为 config.json。后面配置部分有详细说明此 config 定义内容与详解。 root filesystem 容器 root 文件系统(启动的只读文件)，在 config.json 文件内有指定 root.path。 三 运行时与生命周期参考 容器作用域除了访问控制问题，使用运行时创建容器的实体必须能够针对同一容器使用本规范中定义的操作。其他实体使用相同或其他实例的运行时是否可以看到该容器超出本规范的范围。 State 容器状态容器的状态至少 必须 包含以下的属性： ociVersion: string 创建容器时用到的规范的版本号 id: string 容器 ID， 必须 是本地唯一的，但不要求跨主机唯一。 status: string 容器的运行时状态。可能是以下值中的一个: created : 容器已经被创建，但是用户代码未被执行。 running : 容器被创建，且用户代码正在运行。 stopped : 容器被创建，用户代码执行完毕，但不在继续运行。 新的状态可以由运行时自定义，但是它们 必须 用来表示未在上面定义的新运行时状态。 pid: int 主机可见的容器进程 ID。 bundlePath: string 容器 bundle 目录的绝对路径。提供给 consumers 查找容器的配置和 rootfs 。 annotations: map 包含了容器相关的注解列表。如果没提供任何的注解，则 可能 不存在或是个空map。 当使用JSON序列化时，其格式 必须 遵守以下样式： 12345678910&#123; &quot;ociVersion&quot;: &quot;0.2.0&quot;, &quot;id&quot;: &quot;oci-container1&quot;, &quot;status&quot;: &quot;running&quot;, &quot;pid&quot;: 4422, &quot;bundlePath&quot;: &quot;/containers/redis&quot;, &quot;annotations&quot;: &#123; &quot;myKey&quot;: &quot;myValue&quot; &#125;&#125; 有关检索容器的状态信息，请看query state。 LifeCycle 容器的生命周期生命周期描述了从容器被创建到停止退出之间的事件的时间线。 create 命令需要配合 bundle 文件地址和唯一 ID 调用。 必须 通过 config.json 中的配置创建容器的运行时环境，如果运行时无法创建环境， 必须 报错。虽然 必须 创建 config.json 中请求的资源，但用户代码不能在此时运行。此阶段后对 config.json 的任何更改 一定不能 影响到容器。 容器所创建的附加操作基于运行时特征选择性的可能被执行，因此有些操作仅基于当前容器的状态才可能有效(如仅有效于运行态)。 start 命令需要配合容器的唯一 ID 调用。运行时 必须 通过指定的进程执行用户代码。 容器的进程停止， 可能 是由于进程出错，退出，宕机或调用了运行时的 kill 命令。 delete 命令需要配合容器的唯一 ID 调用。 必须回滚在 create 阶段期间执行的步骤销毁容器。 Errors 报错（本规范列举的）操作报错的情况下， 本规范不强制要求具体实现（比如 runc ）如何&#x2F;是否返回或暴露错误给用户。除非另有说明，否则报错后 必须 重置环境的状态到操作没被执行过一样——除了像日志这种比较小的修改。 Operations 操作容器除非底层的操作系统无法支持，否则兼容 OCI 的运行时 必须 支持下列的操作。这些操作不指定任何命令行 API ，并且这些参数是用于一般操作的入参。 Query State 状态查询 1state &lt;container-id&gt; 此操作在不提供容器 ID 时 必须 报错。尝试查询一个不存在的容器 必须 报错。此操作 必须 返回同状态一节指定的容器的状态（信息）。 Create 容器创建 1create &lt;container-id&gt; &lt;path-to-bundle&gt; 此操作在不提供 bundle 文件的路径和容器 ID 时 必须 报错。如果提供了一个在 runtime（管理的）范围内不唯一，或者无效的 ID，其底层实现 必须 报错，且容易 一定不能 被创建。利用 config.json 文件里的数据，此操作 必须 创建一个新的容器，这意味着该容器相关的资源 必须 被创建，但是，用户指定的代码在此阶段 一定不能 被执行。如果运行时不能依照如 config.md 指定的容器，则 必须 报错，且新容器 一定不能 被创建。 成功完成此操作后，此容器的 status 属性值 必须 是 created。 运行时在创建容器前（步骤2），可以 根据此规范一般或相对于当前系统的能力验证 config.json 。 运行时的调用者如果感兴趣 pre-create 校验，可以在此操作（create）前调用 bundle-validation tools 。 成功执行完成此操作后，容器 必须 被创建好。 再此操作执行成功之后，任何针对config.json的修改都不会影响到（创建出来的）容器。 Start 容器运行 1start &lt;container-id&gt; 此操作在不提供容器ID时 必须 报错。尝试启动一个不存在的容器 必须 报错。尝试启动一个已经运行的容器 必须 没有任何效果，且 必须 报错。此操作 必须 由进程运行用户代码。 成功执行完成此操作后，此容器的status属性值 必须 是running。 Kill 容器停止 1kill &lt;container-id&gt; &lt;signal&gt; 此操作在不提供容器ID时 必须 报错。尝试向一个非运行的容器发送信号量， 必须 没有任何效果，并且 必须 报错。此操作 必须 向容器内的进程发送指定的信号量。 当容器内的进程停止了，不管是kill操作还是其他原因导致的，这个容器的status属性值 必须 是stopped Delete 删除容器 1delete &lt;container-id&gt; 此操作在不提供容器 ID 时 必须 报错。尝试删除一个不存在容器 必须 报错。尝试删除一个其进程仍然运行的容器 必须 报错。删除容器 必须 释放其创建时申请的资源。注意，非容器创建的， 但是相关的资源， 一定不能 被删除。一旦容器被删除，它的 ID 可能 分配给后续的容器使用。 Hook 容器执行勾子在本规范中提到的许多操作，都允许在每个操作之前或之后采取附加动作的“钩子”。更多“钩子”的信息请参考运行时配置 hooks 。 Linux 运行时默认情况下，运行时仅为应用程序打开 stdin，stdout 和stderr 的文件描述符。 运行时 也可以 给应用程序传入额外的文件描述，以支持如 socket activation 等功能。 有些文件描述符 可能 被重定向到了 /dev/null，即使他们是打开的。 设备符号链接 当(生命周期管理的步骤2)创建容器时，运行时须创建以下标准的符号链接： Source Destination &#x2F;proc&#x2F;self&#x2F;fd &#x2F;dev&#x2F;fd &#x2F;proc&#x2F;self&#x2F;fd&#x2F;0 &#x2F;dev&#x2F;stdin &#x2F;proc&#x2F;self&#x2F;fd&#x2F;1 &#x2F;dev&#x2F;stdout &#x2F;proc&#x2F;self&#x2F;fd&#x2F;2 &#x2F;dev&#x2F;stderr 四 配置( Linux spec )容器的顶级目录 必须 包含一个名为 config.json 的配置文件。 本文档中定义的是典型的结构，但是还有 JSON 结构 schema&#x2F;config-schema.json 和 Go 版本的 specs-go&#x2F;config.go 。 配置文件包含对容器执行标准操作所需的元数据。这包括运行的进程，要注入的环境变量，要使用的沙箱功能等。 下面是配置文件中定义的每个字段的详细描述。 Specification version ociVersion string, REQUIRED 必须 是符合 SemVer v2.0.0 格式的，并且指定 bundle 符合的开放容器运行时规范的版本。开放容器运行时规范遵守语义化版本并保证 major 版本的向前&#x2F;后兼容性。例如，如果一个配置兼容本规范的1.1版本，则它必须兼容所有支持1.1和后续版本的运行时），但是不兼容支持1.0的运行时。 示例： 1&quot;ociVersion&quot;: &quot;0.1.0&quot; Root Configurationroot 配置容器的 rootfs 。 path string, REQUIRED 指定容器的rootfs路径。 路径可以是绝对路径（以&#x2F;开头），也可以是相对于bundle的相对路径（不以&#x2F;开头）。 举个例子， bundle 的目录是 &#x2F;to&#x2F;bundle，rootfs 的目录是 &#x2F;to&#x2F;bundle&#x2F;rootfs，那么 path 的值可以写成 &#x2F;to&#x2F;bundle&#x2F;rootfs（绝对路径写法）或 rootfs（相对路径写法）。 path 内填写的目录 必须 存在。 readonly bool, OPTIONAL 设置成 true 则容器内的 rootfs 必须 是只读的，默认是 false 。 示例： 1234&quot;root&quot;: &#123; &quot;path&quot;: &quot;rootfs&quot;, &quot;readonly&quot;: true&#125; Mounts mounts 配置额外的 mount (在 root 之上), 参数与 the Linux mount system call 类似。 destination string, REQUIRED 挂载点的目标地址：容器内的路径。此指必须是绝对路径。 type string, REQUIRED 需要 mount 的文件系统类型。支持 &#x2F;proc&#x2F;filesystems 中列举的文件系统类型（如“minix”，“ext2”，“ext3”，“jfs”，“xfs”，“reiserfs”，”msdos“，”proc“，”nfs“, “iso9660”）。 Windows：ntfs。 source string, REQUIRED 设备名，也可以是目录名或虚拟设备。 options list of strings, OPTIONAL 文件系统 mount 参数。 Linux: [supported](http://man7.org/linux/man-pages/man8/mount.8.html#FILESYSTEM-INDEPENDENT_MOUNT OPTIONS) [options](http://man7.org/linux/man-pages/man8/mount.8.html#FILESYSTEM-SPECIFIC_MOUNT OPTIONS) are listed in mount(8). 示例： 1234567891011121314&quot;mounts&quot;: [ &#123; &quot;destination&quot;: &quot;/tmp&quot;, &quot;type&quot;: &quot;tmpfs&quot;, &quot;source&quot;: &quot;tmpfs&quot;, &quot;options&quot;: [&quot;nosuid&quot;,&quot;strictatime&quot;,&quot;mode=755&quot;,&quot;size=65536k&quot;] &#125;, &#123; &quot;destination&quot;: &quot;/data&quot;, &quot;type&quot;: &quot;bind&quot;, &quot;source&quot;: &quot;/volumes/testing&quot;, &quot;options&quot;: [&quot;rbind&quot;,&quot;rw&quot;] &#125;] Process configurationprocess 配置容器的进程。 terminal bool, optional 指定是否需要连接该进程的终端，默认是 false。 consoleSize object, OPTIONAL 指定终端的控制台窗口大小（如果连接了终端），包含以下属性： height uint, REQUIRED width uint, REQUIRED cwd string, REQUIRED 为可执行文件设置工作目录。此值 必须 是绝对路径。 env array of strings, OPTIONAL 包含一组在进程执行前设置到其环境中的变量。数组里的元素指定为 “KEY&#x3D;value” 格式的字符串。左侧（KEY） 必须 只包含字母，数字和下划线’_’，如IEEE Std 1003.1-2001. args array of strings, REQUIRED 可执行文件和一组标志（flags）。可执行文件是第一个数组的第一个元素，并且 必须 存在于给定的路径里。如果可执行文件的路径不是绝对路径，则通过 $PATH 查找可执行文件。 对于基于Linux的系统，进程结构支持以下特定字段： capabilities array of strings, OPTIONAL capabilities是一个数组，用于指定可以提供给容器内部进程的capabilities。有效值均是字符串，且定义在the man page。 rlimits array of rlimits, OPTIONAL rlimits是一个数组，用于指定容器内的进程资源的限制。内核支持两种资源限制模式 soft 和 hard ,hard 表示强制的最高的上限。限制值可可通过一个非特权进程进行设置,有效值与资源类型字段定义在 the man page. apparmorProfile string, OPTIONAL 指定容器使用的 apparmor 配置文件名字。有关 Apparmor 的更多信息，请参考Apparmor documentation。 selinuxLabel string, OPTIONAL 指定容器内进程运行时使用的 SELinux 标签。有关 SELinux 的更多信息，请参考Selinux documentation。 noNewPrivileges bool, OPTIONAL 将 noNewPrivileges 设置成 true 可以阻止容器内的进程申请额外的权限。 The kernel doc上有更多关于该功能如何使用prctl系统调用实现的信息。 User进程的用户是平台特定的结构，允许控制进程以哪个具体的用户运行。 基于Linux和Solaris的系统，用户结构有以下字段： uid (int, REQUIRED) 指定container namespace内的UID。 gid (int, REQUIRED) 指定container namespace内的GID. additionalGids (array of ints, OPTIONAL) 指定添加给进程的额外的GID(在 container namespace内)。 Note: 分别用于uid和gid的symbolic name，例如uname和game，留给更高级去导出（如解析&#x2F;etcpasswd，NSS等）。 Note: Solaris下，uid和gid指定容器内进程的uid和gid，并且不需要和宿主机一致。 示例： 1234567891011121314151617181920212223242526272829303132333435&quot;process&quot;: &#123; &quot;terminal&quot;: true, &quot;consoleSize&quot;: &#123; &quot;height&quot;: 25, &quot;width&quot;: 80 &#125;, &quot;user&quot;: &#123; &quot;uid&quot;: 1, &quot;gid&quot;: 1, &quot;additionalGids&quot;: [5, 6] &#125;, &quot;env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;TERM=xterm&quot; ], &quot;cwd&quot;: &quot;/root&quot;, &quot;args&quot;: [ &quot;sh&quot; ], &quot;apparmorProfile&quot;: &quot;acme_secure_profile&quot;, &quot;selinuxLabel&quot;: &quot;system_u:system_r:svirt_lxc_net_t:s0:c124,c675&quot;, &quot;noNewPrivileges&quot;: true, &quot;capabilities&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot;, &quot;CAP_NET_BIND_SERVICE&quot; ], &quot;rlimits&quot;: [ &#123; &quot;type&quot;: &quot;RLIMIT_NOFILE&quot;, &quot;hard&quot;: 1024, &quot;soft&quot;: 1024 &#125; ]&#125; Hostname hostname string, OPTIONAL 配置容器中运行的进程能看到的容器主机名。Linux环境下，你只能在创建了新的UTS namespace后才能设置此值。 示例： 1&quot;hostname&quot;: &quot;mrsdalloway&quot; Platformplatform 指定了配置的目标平台。 os string, REQUIRED 指定这个镜像对应的操作系统系列。 如果运行时不支持配置的 os 必须 报错。 Bundles SHOULD use, and runtimes SHOULD understand, os entries listed in the Go Language document for $GOOS. 如果某个操作系统没有列在$GOOS的文档里，那么它 应该 被提交到这个规范里做标准化。 arch string, REQUIRED 指定了镜像内二进制文件编译用到的指令集。 如果运行时不支持配置的 arch 必须 报错。 Values for arch SHOULD use, and runtimes SHOULD understand, arch entries listed in the Go Language document for $GOARCH. 如果某个架构没有列在$GOARCH文档里，那么它 应该 被提交到这个规范里做标准化。 示例： 1234&quot;platform&quot;: &#123; &quot;os&quot;: &quot;linux&quot;, &quot;arch&quot;: &quot;amd64&quot;&#125; Platform-specific configurationplatform.os 用于检查进一步的平台相关的配置。 linux (object, OPTIONAL) Linux-specific configuration. 仅当 platform.os 是linux时才推荐设置。 solaris (object, OPTIONAL) Solaris-specific configuration. 仅当 platform.os 是solaris时才推荐设置。 windows (object, optional) Windows-specific configuration. 仅当 platform.os 是windows时才推荐设置。 示例： 12345678910111213&#123; &quot;platform&quot;: &#123; &quot;os&quot;: &quot;linux&quot;, &quot;arch&quot;: &quot;amd64&quot; &#125;, &quot;linux&quot;: &#123; &quot;namespaces&quot;: [ &#123; &quot;type&quot;: &quot;pid&quot; &#125; ] &#125;&#125; Namespaces命名空间将全局系统资源封装在抽象概念中，使得命名空间中的进程看起来具有自己的全局资源的独立实例。 更改全局资源，对属于命名空间成员中的其他进程可见，但对（非成员的）其他进程不可见。 更多信息请参考the man page。 命名空间被指定为 namespaces 字段中的数组。 设置命名空间可以指定以下参数： type string, REQUIRED - 命名空间类型。支持下列命名空间类型： pid 容器内的进程仅能看见同容器内的其他进程。 network 容器有自己的网络栈。 mount 容器有自己的挂载表。 ipc 容器内的进程仅能通过系统级 IPC 与同一容器内的其他进程通信。 uts 容器有自己的主机名和域名。 user 容器能将主机中的用户和组 ID 重新映射到容器内的本地用户和组。 cgroup 容器具有 cgroup 层次结构的独立视图。 path string, OPTIONAL - runtime mount namespace中的命名空间文件路径。 如果没有在 namespaces 数组中指定命名空间类型，则该容器必须继承该类型的运行时命名空间。 如果一个 namespaces 字段包含具有相同 type 的重复命名空间，那么运行时 必须 报错。 示例 12345678910111213141516171819202122232425&quot;namespaces&quot;: [ &#123; &quot;type&quot;: &quot;pid&quot;, &quot;path&quot;: &quot;/proc/1234/ns/pid&quot; &#125;, &#123; &quot;type&quot;: &quot;network&quot;, &quot;path&quot;: &quot;/var/run/netns/neta&quot; &#125;, &#123; &quot;type&quot;: &quot;mount&quot; &#125;, &#123; &quot;type&quot;: &quot;ipc&quot; &#125;, &#123; &quot;type&quot;: &quot;uts&quot; &#125;, &#123; &quot;type&quot;: &quot;user&quot; &#125;, &#123; &quot;type&quot;: &quot;cgroup&quot; &#125; ] User namespace mappings uidMappings array of objects, OPTIONAL 描述从宿主机到容器的用户命名空间 uid 映射。 gidMappings array of objects, OPTIONAL 描述从宿主机到容器的用户命名空间 uid 映射。 每个条目都有以下的结构： hostID uint32, REQUIRED - 将被映射到容器内宿主机上的启始 uid&#x2F;gid containerID uint32, REQUIRED - 在容器内的启始uid&#x2F;gid size uint32, REQUIRED - 被映射的id数量 运行时 不应该 修改引用文件系统的所有权来实现映射。 Linux内核有5个映射的硬限制。 示例 1234567891011121314&quot;uidMappings&quot;: [ &#123; &quot;hostID&quot;: 1000, &quot;containerID&quot;: 0, &quot;size&quot;: 10 &#125; ], &quot;gidMappings&quot;: [ &#123; &quot;hostID&quot;: 1000, &quot;containerID&quot;: 0, &quot;size&quot;: 10 &#125; ] Devices devices array of objects, OPTIONAL 列出容器中 必须 可用的设备。 每个条目都有以下的结构： type string, REQUIRED - 设备类型：c , b , u 或 I。 更多信息参考mknod(1)。 path string, REQUIRED - 容器内设备的完整路径。 major, minor *int64, REQUIRED - 设备的major, minor numbers。 fileMode uint32, OPTIONAL- 设备的文件模式。 你可以通过cgroups控制设备的访问。 uid uint32, OPTIONAL- 设备所有者的ID。 gid uint32, OPTIONAL - 设备归属组的ID。 示例 1234567891011121314151617181920&quot;devices&quot;: [ &#123; &quot;path&quot;: &quot;/dev/fuse&quot;, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;fileMode&quot;: 438, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125;, &#123; &quot;path&quot;: &quot;/dev/sda&quot;, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;fileMode&quot;: 432, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125; ] 默认设备列表： &#x2F;dev&#x2F;null &#x2F;dev&#x2F;zero &#x2F;dev&#x2F;full &#x2F;dev&#x2F;random &#x2F;dev&#x2F;urandom &#x2F;dev&#x2F;tty &#x2F;dev&#x2F;console &#x2F;dev&#x2F;ptmx Control groups称之为cgroups, 被用于容器对资源使用的限制和处理设备的访问限制。cgroups提供通过相应的控制器去限制容器的 cpu 、内存 、IO 、pid 、网络等资源使用。详细信息参考 kernel cgroups documentation. 通过 cgroupsPath 项可指定 cgroups 路径. 通过 resource 项配置容器的资源限制。 Example123456789101112&quot;cgroupsPath&quot;: &quot;/myRuntime/myContainer&quot;, &quot;resources&quot;: &#123; &quot;memory&quot;: &#123; &quot;limit&quot;: 100000, &quot;reservation&quot;: 200000 &#125;, &quot;devices&quot;: [ &#123; &quot;allow&quot;: false, &quot;access&quot;: &quot;rwm&quot; &#125; ] Device whitelistdevices array of objects, OPTIONAL 配置设备的白名单。 列表内的每项包含以下结构： allow boolean, REQUIRED - 实体项是被否允许或拒绝 type string, OPTIONAL - 设备类型: a (all), c (字符), 或 b (块). null 或未设代表 “all” major, minor int64, OPTIONAL - major, minor numbers 设备主、次版本 null 或未设代表 “all” * in the filesystem API. access string, OPTIONAL - 设备cgroup权限. 由r (读), w (写), 和 m(mknod)组成. 示例 1234567891011121314151617181920&quot;devices&quot;: [ &#123; &quot;allow&quot;: false, &quot;access&quot;: &quot;rwm&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;access&quot;: &quot;rw&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;access&quot;: &quot;r&quot; &#125; ] Disable out-of-memory killerdisableOOMKiller 设置布尔值 true 或 false为 cgroup 开启或关闭OOM killer机制.详细可参考 the memory cgroup man page。 disableOOMKiller (bool, OPTIONAL) - 开启或关闭 OOM killer 示例 1&quot;disableOOMKiller&quot;: false Set oom_score_adjoomScoreAdj设置有关当内存压力情况下内核将如何处理进程的启发式方法。详细可参考 the proc filesystem documentation section 3.1. This is a kernel&#x2F;system level setting这是一个内核&#x2F;系统级设置, 其中”disableoomkiller”作用于内存cgroup ,详细可参考 the memory cgroup documentation section 10. OOM Contol. oomScoreAdj int, OPTIONAL - 调节oom-killer的分值 Example1&quot;oomScoreAdj&quot;: 100 Memorymemory object, OPTIONAL 表示用 cgroup 子系统 memory 对容器的内存使用进行限制。详细信息参考 the memory cgroup man page. 可指定的参数配置： limit uint64, OPTIONAL - 设置内存使用限制(bytes) reservation uint64, OPTIONAL - 设置内存使用软限制(bytes) swap uint64, OPTIONAL - 设置内存+swap使用限制 kernel uint64, OPTIONAL - 设置内核内存硬限制 kernelTCP uint64, OPTIONAL - 设置内核TCP缓存内存硬限制 swappiness uint64, OPTIONAL - 设置内存交换限制 Example12345678&quot;memory&quot;: &#123; &quot;limit&quot;: 536870912, &quot;reservation&quot;: 536870912, &quot;swap&quot;: 536870912, &quot;kernel&quot;: 0, &quot;kernelTCP&quot;: 0, &quot;swappiness&quot;: 0 &#125; CPUcpu object, OPTIONAL cgroup 子系统 cpu and cpusets. 详细信息参考 the cpusets cgroup man page. 可配置的参数： shares uint64, OPTIONAL - 指定一个在cgroup内任务的可使用的CPU时间相对比重。 quota uint64, OPTIONAL - 指定在一个周期(由下面的period参数指定)内cgroup内的所有任务运行的总时间值(microseconds) period uint64, OPTIONAL - 仅适用完全公平调度，指定一个CGroup对CPU资源的访问应该多久重新分配一次(microseconds) realtimeRuntime uint64, OPTIONAL - 指定任务占用CPU资源最长连续周期(microseconds) realtimePeriod uint64, OPTIONAL - 如同period，但仅应用于实时调度器 cpus string, OPTIONAL - 容器将被运行的CPU列表 mems string, OPTIONAL - 容器将被运行的内存节点列表 示例 123456789&quot;cpu&quot;: &#123; &quot;shares&quot;: 1024, &quot;quota&quot;: 1000000, &quot;period&quot;: 500000, &quot;realtimeRuntime&quot;: 950000, &quot;realtimePeriod&quot;: 1000000, &quot;cpus&quot;: &quot;2-3&quot;, &quot;mems&quot;: &quot;0-7&quot; &#125; Block IO ControllerblockIO object, OPTIONAL cgroup blkio子系统，实现对块设备IO控制器。详细信息可参考 the kernel cgroups documentation about blkio. 可指定配置参数： blkioWeight uint16, OPTIONAL - 指定每个 cgroup 权限. 取值区间 10 ~ 1000. blkioLeafWeight uint16, OPTIONAL - 相当于 blkioweight ,当竞争产生时的权重.取值区间 10 ~ 1000 blkioWeightDevice array, OPTIONAL - 指定blkio带宽速率限制的设备列表. 每个设备可指定的参数: major, minor int64, REQUIRED - 设备的主、次版本号 weight uint16, OPTIONAL - 设备的blkio带宽速率，取值区间 10~1000 leafWeight uint16, OPTIONAL - 当与 cgroup 的子 cgoup 产生竞争时设备的带宽速率 cgroups, ,值区间10~1000。仅作用于完全公平调度算法 blkioThrottleReadBpsDevice, blkioThrottleWriteBpsDevice, blkioThrottleReadIOPSDevice, blkioThrottleWriteIOPSDevice array, OPTIONAL - IO率限制设备列表 major, minor int64, REQUIRED - 设备的主、次版本号 rate uint64, REQUIRED - 设备的io率限制 Example12345678910111213141516171819202122232425262728293031&quot;blockIO&quot;: &#123; &quot;blkioWeight&quot;: 10, &quot;blkioLeafWeight&quot;: 10, &quot;blkioWeightDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;weight&quot;: 500, &quot;leafWeight&quot;: 300 &#125;, &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;weight&quot;: 500 &#125; ], &quot;blkioThrottleReadBpsDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;rate&quot;: 600 &#125; ], &quot;blkioThrottleWriteIOPSDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;rate&quot;: 300 &#125; ] &#125; Huge page limitshugepageLimits array of objects, OPTIONAL 表示hugetlb控制器允许限制每个控制组的HugeTLB使用和控制器限制错误页, 更多信息参考 kernel cgroups documentation about HugeTLB。 每项有以下结构配置： pageSize string, REQUIRED - hugepage size 大页的大小 limit uint64, REQUIRED - HugeTLB 使用限制 Example123456&quot;hugepageLimits&quot;: [ &#123; &quot;pageSize&quot;: &quot;2MB&quot;, &quot;limit&quot;: 9223372036854771712 &#125; ] Networknetwork object, OPTIONAL 代表 cgroup 的 net_cls 和 net_prio 子系统。 更多信息，参考the net_cls cgroup man page 和 the net_prio cgroup man page。 可以指定以下参数来设置控制器： classID uint32, OPTIONAL - 网络类标识，cgroup网络包被与之关联标记 priorities array, OPTIONAL - 指定分配给来自组中进程并在各接口上出流量优先级的对象列表。 每个优先级可指定的参数: name string, REQUIRED - 网卡名字 priority uint32, REQUIRED - 应用在此网卡的优先级 示例： 12345678910111213&quot;network&quot;: &#123; &quot;classID&quot;: 1048577, &quot;priorities&quot;: [ &#123; &quot;name&quot;: &quot;eth0&quot;, &quot;priority&quot;: 500 &#125;, &#123; &quot;name&quot;: &quot;eth1&quot;, &quot;priority&quot;: 1000 &#125; ] &#125; PIDspids (object, OPTIONAL) 代表cgroup的pids子系统。 更多信息，参考the pids cgroup man page。 可以指定以下参数来设置控制器： limit (int64, REQUIRED) - 指定cgroup下最大任务数量。 示例 123&quot;pids&quot;: &#123; &quot;limit&quot;: 32771 &#125; Sysctl sysctl object, OPTIONAL 允许为容器在运行时对内核参数进行设置，更多信息可以参考 sysctl(8) 示例 1234&quot;sysctl&quot;: &#123; &quot;net.ipv4.ip_forward&quot;: &quot;1&quot;, &quot;net.core.somaxconn&quot;: &quot;256&quot; &#125; SeccompSeccomp 在 linux 内核层为应用提供沙盒机制。seccomp配置允许配置对匹配的syscall执行的操作，并且还允许对作为参数传递给syscalls的值进行匹配，更多信息可以参考 Seccomp 内核文档。 seccomp object, OPTIONAL 可指定配置seccomp的参数如下： defaultAction string, REQUIRED - seccomp执行的默认动作，可配置的值与一致 syscalls[].action architectures array of strings, OPTIONAL - 系统调用所使用的架构 syscalls array of objects, OPTIONAL -在seccomp内匹配syscall 示例 123456789101112&quot;seccomp&quot;: &#123; &quot;defaultAction&quot;: &quot;SCMP_ACT_ALLOW&quot;, &quot;architectures&quot;: [ &quot;SCMP_ARCH_X86&quot; ], &quot;syscalls&quot;: [ &#123; &quot;name&quot;: &quot;getcwd&quot;, &quot;action&quot;: &quot;SCMP_ACT_ERRNO&quot; &#125; ] &#125; Rootfs Mount Propagation rootfsPropagation string, OPTIONAL 设置 rootfs 的挂载传播。 取值是 slave、private 或 shared。 有关于安装传播的更多信息，参考The kernel doc。 示例 1&quot;rootfsPropagation&quot;: &quot;slave&quot; Masked Paths maskedPaths (array of strings, OPTIONAL) 在容器内掩藏提供的路径，使它们无法读取。 这些路径在容器命名空间 必须是绝对路径。 示例 123&quot;maskedPaths&quot;: [ &quot;/proc/kcore&quot;] Readonly Paths readonlyPaths array of strings, OPTIONAL 在容器内设置提供的路径为只读，这些路径在容器命名空间 须 是绝对路径。 示例 123&quot;readonlyPaths&quot;: [ &quot;/proc/sys&quot;] Mount Label mountLabel string, OPTIONAL 为容器挂载的设置 Selinux上下文。 示例 1&quot;mountLabel&quot;: &quot;system_u:object_r:svirt_sandbox_file_t:s0:c715,c811&quot; Hooks hooks object, OPTIONAL 用来配置容器生命周期事件的回调。 Liftcycle hooks允许对容器运行时的许多（逻辑）点自定义事件。 目前有Prestart，Poststart 和 Poststop。 Prestart 容器进程运行前被调用的一组钩子。 Poststart 容器进程运行后立即被调用的一组钩子。 Poststop 容器进程退出后被调用的一组钩子。 钩子允许在容器的各种生命周期事件之前&#x2F;之后运行代码。钩子 必须 按照列表顺序（声明顺序）被调用。容器的状态会通过stdin传入到钩子内，这样钩子（程序）就可以拿到它们工作需要的信息。 钩子的路径是绝对路径，并且可以在runtime namespace中执行。 Prestart pre-start钩子在容器进程产生后，用户提供的命令执行之前被调用。Linux下，他们在容器的namespaces创建以后被调用，因此提供了自定义容器的机会。举个例子， 在此钩子里可以配置network namespace。 如果钩子返回了非零的退出码（参考shell中的$?），则一个包含了退出码和stderr的错误被返回给调用者，同时容器被回收。 Poststart post-start钩子在用户进程运行启动后被调用。举个例子，这个钩子可以通知用户真正产生的进程（的PID或其他balabala）。 如果钩子返回了非零的退出码（参考shell中的$?），记录下错误并继续执行剩下的钩子。 Poststop post-stop钩子在容器进程停止后被调用。可以在此钩子中执行清理或调试工作。 如果钩子返回了非零的退出码（参考shell中的$?），记录下错误并继续执行剩下的钩子。 示例 123456789101112131415161718192021222324&quot;hooks&quot;: &#123; &quot;prestart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/fix-mounts&quot;, &quot;args&quot;: [&quot;fix-mounts&quot;, &quot;arg1&quot;, &quot;arg2&quot;], &quot;env&quot;: [ &quot;key1=value1&quot;] &#125;, &#123; &quot;path&quot;: &quot;/usr/bin/setup-network&quot; &#125; ], &quot;poststart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/notify-start&quot;, &quot;timeout&quot;: 5 &#125; ], &quot;poststop&quot;: [ &#123; &quot;path&quot;: &quot;/usr/sbin/cleanup.sh&quot;, &quot;args&quot;: [&quot;cleanup.sh&quot;, &quot;-f&quot;] &#125; ] &#125; Annotations annotations object, OPTIONAL 包含了容器的任意元数据。 这些元数据信息 可能 是结构化的或非结构化的。 注解 必须 是键值对映射，而且键值 必须 是字符串。 值 必须 存在，但 可能 是空字符串。 键在映射中 必须 是唯一的，最好的办法就是使用命名空间。 键 应该 以反向域名的方式命名 —— 比如 com.example.myKey 。org.opencontainers 命名空间下的键是保留关键字，并且 一定不能 被后续的规范使用。 如果没有注解，此值 可能 不存在或者是空映射。 正在读取&#x2F;处理配置文件的实现 一定不能 在遇到一个未知属性时报错。 示例 123&quot;annotations&quot;: &#123; &quot;com.example.gpu-cores&quot;: &quot;2&quot;&#125; Extensibility正在读取&#x2F;处理配置文件的（runtime）实现 一定不能 在遇到一个未知属性时报错，而是 必须 忽略这些未知的属性。 config.json 完整的配置示例供参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349&#123; &quot;ociVersion&quot;: &quot;0.5.0-dev&quot;, &quot;platform&quot;: &#123; &quot;os&quot;: &quot;linux&quot;, &quot;arch&quot;: &quot;amd64&quot; &#125;, &quot;process&quot;: &#123; &quot;terminal&quot;: true, &quot;user&quot;: &#123; &quot;uid&quot;: 1, &quot;gid&quot;: 1, &quot;additionalGids&quot;: [ 5, 6 ] &#125;, &quot;args&quot;: [ &quot;sh&quot; ], &quot;env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;TERM=xterm&quot; ], &quot;cwd&quot;: &quot;/&quot;, &quot;capabilities&quot;: [ &quot;CAP_AUDIT_WRITE&quot;, &quot;CAP_KILL&quot;, &quot;CAP_NET_BIND_SERVICE&quot; ], &quot;rlimits&quot;: [ &#123; &quot;type&quot;: &quot;RLIMIT_CORE&quot;, &quot;hard&quot;: 1024, &quot;soft&quot;: 1024 &#125;, &#123; &quot;type&quot;: &quot;RLIMIT_NOFILE&quot;, &quot;hard&quot;: 1024, &quot;soft&quot;: 1024 &#125; ], &quot;apparmorProfile&quot;: &quot;acme_secure_profile&quot;, &quot;selinuxLabel&quot;: &quot;system_u:system_r:svirt_lxc_net_t:s0:c124,c675&quot;, &quot;noNewPrivileges&quot;: true &#125;, &quot;root&quot;: &#123; &quot;path&quot;: &quot;rootfs&quot;, &quot;readonly&quot;: true &#125;, &quot;hostname&quot;: &quot;slartibartfast&quot;, &quot;mounts&quot;: [ &#123; &quot;destination&quot;: &quot;/proc&quot;, &quot;type&quot;: &quot;proc&quot;, &quot;source&quot;: &quot;proc&quot; &#125;, &#123; &quot;destination&quot;: &quot;/dev&quot;, &quot;type&quot;: &quot;tmpfs&quot;, &quot;source&quot;: &quot;tmpfs&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;strictatime&quot;, &quot;mode=755&quot;, &quot;size=65536k&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/pts&quot;, &quot;type&quot;: &quot;devpts&quot;, &quot;source&quot;: &quot;devpts&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;newinstance&quot;, &quot;ptmxmode=0666&quot;, &quot;mode=0620&quot;, &quot;gid=5&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/shm&quot;, &quot;type&quot;: &quot;tmpfs&quot;, &quot;source&quot;: &quot;shm&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot;, &quot;mode=1777&quot;, &quot;size=65536k&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/dev/mqueue&quot;, &quot;type&quot;: &quot;mqueue&quot;, &quot;source&quot;: &quot;mqueue&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/sys&quot;, &quot;type&quot;: &quot;sysfs&quot;, &quot;source&quot;: &quot;sysfs&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot; ] &#125;, &#123; &quot;destination&quot;: &quot;/sys/fs/cgroup&quot;, &quot;type&quot;: &quot;cgroup&quot;, &quot;source&quot;: &quot;cgroup&quot;, &quot;options&quot;: [ &quot;nosuid&quot;, &quot;noexec&quot;, &quot;nodev&quot;, &quot;relatime&quot;, &quot;ro&quot; ] &#125; ], &quot;hooks&quot;: &#123; &quot;prestart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/fix-mounts&quot;, &quot;args&quot;: [ &quot;fix-mounts&quot;, &quot;arg1&quot;, &quot;arg2&quot; ], &quot;env&quot;: [ &quot;key1=value1&quot; ] &#125;, &#123; &quot;path&quot;: &quot;/usr/bin/setup-network&quot; &#125; ], &quot;poststart&quot;: [ &#123; &quot;path&quot;: &quot;/usr/bin/notify-start&quot;, &quot;timeout&quot;: 5 &#125; ], &quot;poststop&quot;: [ &#123; &quot;path&quot;: &quot;/usr/sbin/cleanup.sh&quot;, &quot;args&quot;: [ &quot;cleanup.sh&quot;, &quot;-f&quot; ] &#125; ] &#125;, &quot;linux&quot;: &#123; &quot;devices&quot;: [ &#123; &quot;path&quot;: &quot;/dev/fuse&quot;, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;fileMode&quot;: 438, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125;, &#123; &quot;path&quot;: &quot;/dev/sda&quot;, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;fileMode&quot;: 432, &quot;uid&quot;: 0, &quot;gid&quot;: 0 &#125; ], &quot;uidMappings&quot;: [ &#123; &quot;hostID&quot;: 1000, &quot;containerID&quot;: 0, &quot;size&quot;: 32000 &#125; ], &quot;gidMappings&quot;: [ &#123; &quot;hostID&quot;: 1000, &quot;containerID&quot;: 0, &quot;size&quot;: 32000 &#125; ], &quot;sysctl&quot;: &#123; &quot;net.ipv4.ip_forward&quot;: &quot;1&quot;, &quot;net.core.somaxconn&quot;: &quot;256&quot; &#125;, &quot;cgroupsPath&quot;: &quot;/myRuntime/myContainer&quot;, &quot;resources&quot;: &#123; &quot;network&quot;: &#123; &quot;classID&quot;: 1048577, &quot;priorities&quot;: [ &#123; &quot;name&quot;: &quot;eth0&quot;, &quot;priority&quot;: 500 &#125;, &#123; &quot;name&quot;: &quot;eth1&quot;, &quot;priority&quot;: 1000 &#125; ] &#125;, &quot;pids&quot;: &#123; &quot;limit&quot;: 32771 &#125;, &quot;hugepageLimits&quot;: [ &#123; &quot;pageSize&quot;: &quot;2MB&quot;, &quot;limit&quot;: 9223372036854772000 &#125; ], &quot;oomScoreAdj&quot;: 100, &quot;memory&quot;: &#123; &quot;limit&quot;: 536870912, &quot;reservation&quot;: 536870912, &quot;swap&quot;: 536870912, &quot;kernel&quot;: 0, &quot;kernelTCP&quot;: 0, &quot;swappiness&quot;: 0 &#125;, &quot;cpu&quot;: &#123; &quot;shares&quot;: 1024, &quot;quota&quot;: 1000000, &quot;period&quot;: 500000, &quot;realtimeRuntime&quot;: 950000, &quot;realtimePeriod&quot;: 1000000, &quot;cpus&quot;: &quot;2-3&quot;, &quot;mems&quot;: &quot;0-7&quot; &#125;, &quot;disableOOMKiller&quot;: false, &quot;devices&quot;: [ &#123; &quot;allow&quot;: false, &quot;access&quot;: &quot;rwm&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;c&quot;, &quot;major&quot;: 10, &quot;minor&quot;: 229, &quot;access&quot;: &quot;rw&quot; &#125;, &#123; &quot;allow&quot;: true, &quot;type&quot;: &quot;b&quot;, &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;access&quot;: &quot;r&quot; &#125; ], &quot;blockIO&quot;: &#123; &quot;blkioWeight&quot;: 10, &quot;blkioLeafWeight&quot;: 10, &quot;blkioWeightDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;weight&quot;: 500, &quot;leafWeight&quot;: 300 &#125;, &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;weight&quot;: 500 &#125; ], &quot;blkioThrottleReadBpsDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 0, &quot;rate&quot;: 600 &#125; ], &quot;blkioThrottleWriteIOPSDevice&quot;: [ &#123; &quot;major&quot;: 8, &quot;minor&quot;: 16, &quot;rate&quot;: 300 &#125; ] &#125; &#125;, &quot;rootfsPropagation&quot;: &quot;slave&quot;, &quot;seccomp&quot;: &#123; &quot;defaultAction&quot;: &quot;SCMP_ACT_ALLOW&quot;, &quot;architectures&quot;: [ &quot;SCMP_ARCH_X86&quot; ], &quot;syscalls&quot;: [ &#123; &quot;name&quot;: &quot;getcwd&quot;, &quot;action&quot;: &quot;SCMP_ACT_ERRNO&quot; &#125; ] &#125;, &quot;namespaces&quot;: [ &#123; &quot;type&quot;: &quot;pid&quot; &#125;, &#123; &quot;type&quot;: &quot;network&quot; &#125;, &#123; &quot;type&quot;: &quot;ipc&quot; &#125;, &#123; &quot;type&quot;: &quot;uts&quot; &#125;, &#123; &quot;type&quot;: &quot;mount&quot; &#125;, &#123; &quot;type&quot;: &quot;user&quot; &#125;, &#123; &quot;type&quot;: &quot;cgroup&quot; &#125; ], &quot;maskedPaths&quot;: [ &quot;/proc/kcore&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot; ], &quot;readonlyPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ], &quot;mountLabel&quot;: &quot;system_u:object_r:svirt_sandbox_file_t:s0:c715,c811&quot; &#125;, &quot;annotations&quot;: &#123; &quot;com.example.key1&quot;: &quot;value1&quot;, &quot;com.example.key2&quot;: &quot;value2&quot; &#125;&#125; ~~ 本文 END ~~","tags":["docker","containerd"],"categories":["技术文档","docker源码分析","OCI"]},{"title":"RunC 源码通读指南之 NameSpace","path":"/2023/01/16/RunC_NameSpace/","content":"概述随着 docker 的诞生和容器技术应用与高速发展，长期一直在后台默默奉献一些 linux 特性如 namespace、cgroup 等技术走向前台。Namespace 是 linux 内核所提供的特性，用于隔离内核资源的方式，可以说没有隔离就不会存在容器。 Linux 官方描述” namespace 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。”详细介绍namespace说明参考 。 Linux 内核里面实现了7种不同类型的 namespace: 12345678名称 宏定义 隔离内容Cgroup CLONE_NEWCGROUP Cgroup root directory IPC CLONE_NEWIPC System V IPC, POSIX message queues Network CLONE_NEWNET Network devices, stacks, ports, etc. Mount CLONE_NEWNS Mount pointsPID CLONE_NEWPID Process IDs User CLONE_NEWUSER User and group IDs UTS CLONE_NEWUTS Hostname and NIS domain name 本文将聚焦在 runC 源码关于容器初始化过程中 namespace 如何应用与实现资源隔离。 从容器的 run 执行流程来看： 容器对象创建阶段 startContainer() &#x3D;&gt; createContainer() &#x3D;&gt; loadFactory() &#x3D;&gt; libcontainer.New() 完成 container 对象的创建后, startContainer() 中已创建的 runner 对象 run() 方法执行，进入容器对象运行阶段: startContainer() &#x3D;&gt; runner.run() &#x3D;&gt; newProcess() &#x3D;&gt; runner.container.Run(process) &#x3D;&gt; linuxContainer.strat() &#x3D;&gt; linuxContainer.newParentProcess(process) &#x3D;&gt; &#x3D;&gt;linuxContainer.commandTemplate() &#x3D;&gt; linuxContaine.newInitProcess() &#x3D;&gt;parent.start() &#x3D;&gt; initProcess.start() 。 Parent.start() 执行其实则是 runC init 命令的执行: ParentProcces 创建runC init子进程，中间会被 &#x2F;runc&#x2F;libcontainer&#x2F;nsenter 劫持( c 代码部分 preamble )，使 runc init 子进程位于容器配置指定的各个 namespace 内（实现 namespace配置 ） ParentProcess 用init管道将容器配置信息传输给runC init进程，runC init再据此配置信息进行容器的初始化操作。初始化完成之后，再向另一个管道exec.fifo进行写操作，进入阻塞状态等待runC start 因此本文我们将从两个方面展开分析，第一则是 runC init 流程执行关于 namespace 设置的时机，第二则是 c 代码部分 nsenter 的实现（ namespace 关键应用代码）。 RunC init 执行流程与 namespace创建容器的 init 进程时相关 \u000enamespace 配置项 !FILENAME libcontainer&#x2F;container_linux.go:512 1234567891011121314151617181920212223242526272829func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) &#123;\tcmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_INITTYPE=&quot;+string(initStandard))\tnsMaps := make(map[configs.NamespaceType]string) for _, ns := range c.config.Namespaces &#123; // 容器 namesapces 配置 if ns.Path != &quot;&quot; &#123; nsMaps[ns.Type] = ns.Path &#125;\t&#125;\t_, sharePidns := nsMaps[configs.NEWPID] // 创建 init 进程同步namespace配置项数据（后面有详述bootstrapData）\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\tif err != nil &#123; return nil, err\t&#125;\tinit := &amp;initProcess&#123; cmd: cmd, messageSockPair: messageSockPair, logFilePair: logFilePair, manager: c.cgroupManager, intelRdtManager: c.intelRdtManager, config: c.newInitConfig(p), container: c, process: p, bootstrapData: data, // 指定 init process bootstrapData值 sharePidns: sharePidns,\t&#125;\tc.initProcess = init\treturn init, nil&#125; InitProcess.start() 容器的初始化配置，此处 cmd.start() 调用实则是 runC init命令执行: 先执行 nsenter C代码部分，实现对container的process进行Namespace相关设置如uid&#x2F;gid、pid、uts、ns、cgroup等。 返执行 init 命令 Go 代码部分，LinuxFactory.StartInitialization()对网络&#x2F;路由、rootfs、selinux、console、主机名、apparmor、Sysctl、seccomp、capability等容器配置 !FILENAME libcontainer&#x2F;process_linux.go:282 1234567891011121314151617func (p *initProcess) start() error &#123; // 当前执行空间进程称为bootstrap进程 // 启动了 cmd，即启动了 runc init 命令,创建 runc init 子进程 // 同时也激活了C代码nsenter模块的执行（为了 namespace 的设置 clone 了三个进程parent、child、init） // C 代码执行后返回 go 代码部分,最后的 init 子进程为了好区分此处命名为&quot; nsInit &quot;（即配置了Namespace的init） // runc init go代码为容器初始化其它部分(网络、rootfs、路由、主机名、console、安全等) err := p.cmd.Start() // +runc init 命令执行，Namespace应用代码执行空间时机 //... if p.bootstrapData != nil &#123; // 将 bootstrapData 写入到 parent pipe 中，此时 runc init 可以从 child pipe 里读取到这个数据 if _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != nil &#123; return newSystemErrorWithCause(err, &quot;copying bootstrap data to pipe&quot;) &#125;\t&#125; //...&#125; 此时来到 runC init 命令执行代码部分，前面有说到先执行 nsenter C 代码逻辑（后面详述），再返回到 Go init 代码部分，而Go init 代码部分不是本文 namespace 介绍的重点，考虑到执行流程理解的连续性，我先简述一下此块，有助于将整个过程串联起来理解。 RunC init 命令执行 Go 调用 C 代码称之 preamble ,即在 import nsenter 模块时机将会在 Go 的 runtime 启动之前，先执行此先导代码块，nsenter 的初始化 init(void) 方法内对 nsexec() 调用 。 !FILENAME init.go:10 1_ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot; !FILENAME libcontainer&#x2F;nsenter&#x2F;nsenter.go:3 123456789package nsenter/*#cgo CFLAGS: -Wallextern void nsexec();void __attribute__((constructor)) init(void) &#123;\tnsexec();&#125;*/import &quot;C&quot; 注：此处 C 代码 nsexec() 分析部分将后面将详细解析 再执行 go 代码 init 命令执行逻辑部分,创建 factory 对象，执行 factory.StartInitialization() &#x3D;&gt; linuxStandardInit.Init() 完成容器的相关初始化配置(网络&#x2F;路由、rootfs、selinux、console、主机名、apparmor、Sysctl、seccomp、capability 等) !FILENAME init.go:15 12345678910111213func init() &#123; //...var initCommand = cli.Command&#123;\tName: &quot;init&quot;,\tUsage: `initialize the namespaces and launch the process (do not call it outside of runc)`,\tAction: func(context *cli.Context) error &#123; factory, _ := libcontainer.New(&quot;&quot;) // +创建 factory 对象 if err := factory.StartInitialization(); err != nil &#123; // +执行 init 初始化 os.Exit(1) &#125; panic(&quot;libcontainer: container init failed to exec&quot;)\t&#125;,&#125; libcontainer.New() 创建 factory 对象返回 !FILENAME libcontainer&#x2F;factory_linux.go:131 12345678func New(root string, options ...func(*LinuxFactory) error) (Factory, error) &#123; //...\tl := &amp;LinuxFactory&#123; //...\t&#125; //... return l, nil&#125; 创建 container 容器对象 !FILENAME libcontainer&#x2F;factory_linux.go:188 1234567func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) &#123; // 创建 linux 容器结构\tc := &amp;linuxContainer&#123; //...\t&#125;\treturn c, nil&#125; Linux 版本的 factory 实现，查看 StartInitialization() 实现代码 !FILENAME libcontainer&#x2F;factory_linux.go:282 1234567func (l *LinuxFactory) StartInitialization() (err error) &#123; //...\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd) //... // newContainerInit()返回的initer实现对象的Init()方法调用 &quot;linuxStandardInit.Init()&quot; return i.Init() &#125; 网络&#x2F;路由、rootfs、selinux、console、主机名、apparmor、sysctl、seccomp、capability 等容器的相关初始化配置。管道 exec.fifo 进行写操作，进入阻塞状态等待 runC start !FILENAME libcontainer&#x2F;standard_init_linux.go:46 123456789101112131415161718192021222324252627282930313233343536func (l *linuxStandardInit) Init() error &#123; //... // 留意此两个关于网络nework/route配置，将专文详细介绍network // 配置network, // 配置路由 // selinux配置 // + 准备rootfs // 配置console // 完成rootfs设置 // 主机名设置 // 应用apparmor配置 // Sysctl系统参数调节 // path只读属性配置 // 告诉runC进程，我们已经完成了初始化工作 // 进程标签设置 // seccomp配置 // 设置正确的capability，用户以及工作目录 // 确定用户指定的容器进程在容器文件系统中的路径 // 关闭管道，告诉runC进程，我们已经完成了初始化工作 // 在exec用户进程之前等待exec.fifo管道在另一端被打开 // 我们通过/proc/self/fd/$fd打开它 // ...... // 向exec.fifo管道写数据，阻塞，直到用户调用`runc start`，读取管道中的数据 // 此时当前进程已处于阻塞状态，等待信号执行后面代码 //\tif _, err := unix.Write(fd, []byte(&quot;0&quot;)); err != nil &#123; return newSystemErrorWithCause(err, &quot;write 0 exec fifo&quot;)\t&#125; // 关闭fifofd管道 fix CVE-2016-9962 // 初始化Seccomp配置 // 调用系统exec()命令，执行entrypoint\tif err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil &#123; return newSystemErrorWithCause(err, &quot;exec user process&quot;)\t&#125;\treturn nil&#125; 此时整个 run 的容器执行流程在执行用户程序 entrypoint 后已接近尾声。从整个执行过程来看 namespace 的配置逻辑主要在 nsenter C 代码内，下面先简要查看 runc 内对 namespace 相关的定义与实现方法，后面将详细介绍 nsenter 的逻辑代码实现。 RunC Namespace 定义与实现先来看一下容器内的执行进程 config 配置的 namespaces 定义 !FILENAME libcontainer&#x2F;configs&#x2F;config.go:81 123456// Config defines configuration options for executing a process inside a contained environment.type Config struct &#123; //...\tNamespaces Namespaces `json:&quot;namespaces&quot;` // NameSpaces 在 config 定义 //...&#125; !FILENAME libcontainer&#x2F;configs&#x2F;namespaces.go:5 1type Namespaces []Namespace // Namespace 类型slice !FILENAME libcontainer&#x2F;configs&#x2F;namespaces_linux.go:80 1234type Namespace struct &#123;\tType NamespaceType `json:&quot;type&quot;`\tPath string `json:&quot;path&quot;`&#125; GetPath() 获取 namespace 路径”&#x2F;proc&#x2F;$pid&#x2F;ns&#x2F;$nsType” !FILENAME libcontainer&#x2F;configs&#x2F;namespaces_linux.go:85 12345678910111213141516171819202122232425// 获取指定pid的指定类型 namespace 路径&quot;/proc/$pid/ns/$nsType&quot;func (n *Namespace) GetPath(pid int) string &#123;\treturn fmt.Sprintf(&quot;/proc/%d/ns/%s&quot;, pid, NsName(n.Type))&#125;// Namespace类型字串转化为系统文件名func NsName(ns NamespaceType) string &#123;\tswitch ns &#123;\tcase NEWNET: return &quot;net&quot;\tcase NEWNS: return &quot;mnt&quot;\tcase NEWPID: return &quot;pid&quot;\tcase NEWIPC: return &quot;ipc&quot;\tcase NEWUSER: return &quot;user&quot;\tcase NEWUTS: return &quot;uts&quot;\tcase NEWCGROUP: return &quot;cgroup&quot;\t&#125;\treturn &quot;&quot;&#125; Namespaces 类提供的操作方法列表 !FILENAME libcontainer&#x2F;configs&#x2F;namespaces_linux.go:89 12345678910111213141516// 删除,从Namespaces slice中删除指定类型的Namespace项func (n *Namespaces) Remove(t NamespaceType) bool &#123;//...&#125;// 增加func (n *Namespaces) Add(t NamespaceType, path string) &#123;//...&#125;// 是否存在func (n *Namespaces) Contains(t NamespaceType) bool &#123;//...&#125;// 获取指定Namespace类型的Pathfunc (n *Namespaces) PathOf(t NamespaceType) string &#123;//...&#125; ParentProcess 用 init 管道将容器配置信息传输给 runc init 进程，那么我们就来看一下 init 管道所传输的 bootstrapData 数据内容的定义，bootstrapData()最后返回序列化后的数据读取器io reader !FILENAME libcontainer&#x2F;container_linux.go:1945 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) &#123; // 创建 netlink 消息\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\t// 写入 cloneFlags r.AddData(&amp;Int32msg&#123; Type: CloneFlagsAttr, Value: uint32(cloneFlags),\t&#125;)\t// 写入自定义 namespace paths\tif len(nsMaps) &gt; 0 &#123; nsPaths, err := c.orderNamespacePaths(nsMaps) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: NsPathsAttr, Value: []byte(strings.Join(nsPaths, &quot;,&quot;)), &#125;)\t&#125; // 为新 user 写入 ns paths\t_, joinExistingUser := nsMaps[configs.NEWUSER]\tif !joinExistingUser &#123; // write uid mappings if len(c.config.UidMappings) &gt; 0 &#123; if c.config.RootlessEUID &amp;&amp; c.newuidmapPath != &quot;&quot; &#123; r.AddData(&amp;Bytemsg&#123; Type: UidmapPathAttr, Value: []byte(c.newuidmapPath), &#125;) &#125; b, err := encodeIDMapping(c.config.UidMappings) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: UidmapAttr, Value: b, &#125;) &#125; // 写 gid mappings if len(c.config.GidMappings) &gt; 0 &#123; b, err := encodeIDMapping(c.config.GidMappings) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: GidmapAttr, Value: b, &#125;) if c.config.RootlessEUID &amp;&amp; c.newgidmapPath != &quot;&quot; &#123; r.AddData(&amp;Bytemsg&#123; Type: GidmapPathAttr, Value: []byte(c.newgidmapPath), &#125;) &#125; if requiresRootOrMappingTool(c.config) &#123; r.AddData(&amp;Boolmsg&#123; Type: SetgroupAttr, Value: true, &#125;) &#125; &#125;\t&#125;\tif c.config.OomScoreAdj != nil &#123; // 如存在配置 OomScorAdj ，写 oom_score_adj r.AddData(&amp;Bytemsg&#123; Type: OomScoreAdjAttr, Value: []byte(fmt.Sprintf(&quot;%d&quot;, *c.config.OomScoreAdj)), &#125;)\t&#125;\t// 写 rootless\tr.AddData(&amp;Boolmsg&#123; Type: RootlessEUIDAttr, Value: c.config.RootlessEUID,\t&#125;)\treturn bytes.NewReader(r.Serialize()), nil&#125; Nsenter C代码解析刚读这段代码时有些理解上混乱，多层父子进行之间交错传递，经过反复仔细重读和推敲代码后才逐渐清晰作者的 代码逻辑思想。 在初期理解代码逻辑时本人存在的几个疑惑点： 为什么需要 fork 三层级关系的进程来实现 namespaces 的配置？ 是否每次 fork 的子进程将继承其父的 namespaces 配置 ？ 是否有什么值传回给bootstrap进程？ 我相信看完代码分析后能得到答案。 Runc init 会有三个进程: 第一个进程称为“ parent ”，读取 bootstrapData 并解析为 Config，对 User map 设置，并通过消息协调后面两个进程的运行管理，在收到 grandchild 回复任务完成消息后退出。 第二个进程称为“ child ”,由 Parent 创建，完成 namespace 的设置 ，fork 出 grandChild 进程并发送给Parent 后发送任务完成消息后退出。 第三个进程称为“ grandChild ”或” init “，进行最后的环境准备工作(sid、uid、gid、cgroup namespace)，执行完成后return 至 init Go runtime 代码处继续执行最后进入 go 代码。 先来看下 Init pipe 配置 datas 读取并解析后的 config 定义 !FILENAME libcontainer&#x2F;nsenter&#x2F;nsexec.c:70 123456789101112131415161718192021222324struct nlconfig_t &#123;\tchar *data;\t/* Process settings. */\tuint32_t cloneflags;\tchar *oom_score_adj;\tsize_t oom_score_adj_len;\t/* User namespace settings. */\tchar *uidmap;\tsize_t uidmap_len;\tchar *gidmap;\tsize_t gidmap_len;\tchar *namespaces;\tsize_t namespaces_len;\tuint8_t is_setgroup;\t/* Rootless container settings. */\tuint8_t is_rootless_euid;\t/* boolean */\tchar *uidmappath;\tsize_t uidmappath_len;\tchar *gidmappath;\tsize_t gidmappath_len;&#125;; Nsexec() 为 nsenter 主干执行逻辑代码,所有 namespaces 配置都在此 func 内执行完成 !FILENAME libcontainer&#x2F;nsenter&#x2F;nsexec.c:575 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void nsexec(void)&#123;\tint pipenum;\tjmp_buf env;\tint sync_child_pipe[2], sync_grandchild_pipe[2]; //用于后面child和grandchild进程通信\tstruct nlconfig_t config = &#123; 0 &#125;; // 配置发送给父进程的 logs 管道\tsetup_logpipe(); // 从环境变量 _LIBCONTAINER_INITPIPE 中取得 child pipe 的 fd 编号 // linuxContainer.commandTemplate() 指定了容器相关的环境变量&quot; _LIBCONTAINER_* &quot;\tpipenum = initpipe();\tif (pipenum == -1) // 由于正常启动的 runc 是没有这个环境变量的，所以这里会直接返回，然后就开始正常的执行 go 程序了 return; // 确保当前的二进制文件是已经复制过的，用来规避 CVE-2019-5736 漏洞 // ensure_cloned_binary 中使用了两种方法： // - 使用 memfd，将二进制文件写入 memfd，然后重启 runc // - 复制二进制文件到临时文件，然后重启 runc\tif (ensure_cloned_binary() &lt; 0) bail(&quot;could not ensure we are a cloned binary&quot;);\twrite_log(DEBUG, &quot;nsexec started&quot;); // 从 child pipe 中读取 namespace config 并解析为 config 结构 // &quot;child pipe&quot; 为 linuxContainer.newParentProcess() 创建 init pipe（sockPair）\tnl_parse(pipenum, &amp;config); // 设置 oom score，这个只能在特权模式下设置，所以在这里就要修改完成\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len); // 设置进程不可 dump\tif (config.namespaces) &#123; if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) &lt; 0) bail(&quot;failed to set process as non-dumpable&quot;);\t&#125; // 创建和子进程通信的 pipe,sync_child_pipe 前面有定义\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) &lt; 0) bail(&quot;failed to setup sync pipe between parent and child&quot;); // 创建和孙进程通信的 pipe,sync_grandchild_pipe 前面有定义\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) &lt; 0) bail(&quot;failed to setup sync pipe between parent and grandchild&quot;); // setjmp 将当前执行位置的环境保存下来，用于多进程环境下的程序跳转 // 此处因后面对自身进行 fork 进程，通过不同进程的 env 值进行跳转逻辑执行 switch (setjmp(env)) &#123; // +后面详述 //... &#125; Parent 父进程创建子进程( Child 自身也创建子进程称为 Grandchild ).接收 child 配置 uid_map 和 gid_map 请求消息 ,为容器与宿主完成 uid&#x2F;gid range 映射后发送确认给 child ；在接收到 child 发送的 grand pid 后，通过容器外传进来的 child pipe 把子和孙进程 PID，写回去，然后让容器外的 runc（bootstrap进程）接管 PID；然后等待child 完成任务消息。其后发送 grandchild 准备运行消息后等待 grandchild 回复完成任务消息后退出进程。 !FILENAME libcontainer&#x2F;nsenter&#x2F;nsexec.c:700 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133\t/* * Stage 0: We&#x27;re in the parent. Our job is just to create a new child * (stage 1: JUMP_CHILD) process and write its uid_map and * gid_map. That process will go on to create a new process, then * it will send us its PID which we will send to the bootstrap * process. */// 第一次执行的时候 setjmp 返回 0，对应 JUMP_PARENTcase JUMP_PARENT:&#123; int len; pid_t child, first_child = -1; bool ready = false; /* For debugging. */ prctl(PR_SET_NAME, (unsigned long)&quot;runc:[0:PARENT]&quot;, 0, 0, 0); // clone_parent 创建了和当前进程完全一致的一个进程（子进程） // 在 clone_parent 中，通过 longjmp() 跳转到 env 保存的位置 // 并且 setjmp 返回值为 JUMP_CHILD // 这样这个子进程就会根据 switch 执行到 JUMP_CHILD 分支 // 而当前 runc init 和 子 runc init 之间通过上面创建的 // sync_child_pipe 进行同步通信 child = clone_parent(&amp;env, JUMP_CHILD); if (child &lt; 0) bail(&quot;unable to fork: child_func&quot;); // 通过 sync_child_pipe 循环读取来自子进程的消息，“消息”定义如下： // enum sync_t &#123; // SYNC_USERMAP_PLS = 0x40,\t/* Request parent to map our users. */ // SYNC_USERMAP_ACK = 0x41,\t/* Mapping finished by the parent. */ // SYNC_RECVPID_PLS = 0x42,\t/* Tell parent we&#x27;re sending the PID. */ // SYNC_RECVPID_ACK = 0x43,\t/* PID was correctly received by parent. */ // SYNC_GRANDCHILD = 0x44,\t/* The grandchild is ready to run. */ // SYNC_CHILD_READY = 0x45,\t/* The child or grandchild is ready to return. */ // &#125;; // 与 child 子进程互通消息并处理 // 通过 sync_child_pipe 循环读取来自子进程的消息 while (!ready) &#123; enum sync_t s; syncfd = sync_child_pipe[1]; close(sync_child_pipe[0]); // 等待(读取) Child 的消息 if (read(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with child: next state&quot;); switch (s) &#123; // 这里设置 user map，因为子进程修改自身的 user namespace 之后，就没有权限再设置 user map 了 case SYNC_USERMAP_PLS: // 收到子进程请求设置 usermap 消息 if (config.is_rootless_euid &amp;&amp; !config.is_setgroup) update_setgroups(child, SETGROUPS_DENY); /* Set up mappings. */ update_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len); update_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len); // 向子进程发送 SYNC_USERMAP_ACK，表示处理完成 s = SYNC_USERMAP_ACK; if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with child: write(SYNC_USERMAP_ACK)&quot;); &#125; break; case SYNC_RECVPID_PLS:&#123; // 收到子进程传递的 grandchild 的 PID 接收请求消息 first_child = child; // 接收孙进程的pid if (read(syncfd, &amp;child, sizeof(child)) != sizeof(child)) &#123; kill(first_child, SIGKILL); bail(&quot;failed to sync with child: read(childpid)&quot;); &#125; s = SYNC_RECVPID_ACK; // 回复接收确认消息给 child if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(first_child, SIGKILL); kill(child, SIGKILL); bail(&quot;failed to sync with child: write(SYNC_RECVPID_ACK)&quot;); &#125; // 通过容器外传进来的 child pipe 把子和孙进程 PID，写回去，然后让容器外的 runc 接管 PID // 这个是因为 clone_parent 的时候参数传了 CLONE_PARENT，导致子孙的父进程都是容器外的那 // 个 runc， 所以当前进程无法接管这些 PID len = dprintf(pipenum, &quot;&#123;\\&quot;pid\\&quot;: %d, \\&quot;pid_first\\&quot;: %d&#125; &quot;, child, first_child); if (len &lt; 0) &#123; kill(child, SIGKILL); bail(&quot;unable to generate JSON for child pid&quot;); &#125; &#125; break; case SYNC_CHILD_READY: // 收到子进程任务完成消息 // 子进程已经处理完了所有事情，父进程可退出循环 ready = true; break; default: bail(&quot;unexpected sync value: %u&quot;, s); &#125; &#125; // 与 Grandchild 孙进程互通消息并处理 // 通过 sync_grandchild_pipe 循环读取来自孙进程的消息 ready = false; while (!ready) &#123; enum sync_t s; syncfd = sync_grandchild_pipe[1]; close(sync_grandchild_pipe[0]); s = SYNC_GRANDCHILD; // 发送 &quot;SYNC_GRANDCHILD&quot; 准备运行消息 if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with child: write(SYNC_GRANDCHILD)&quot;); &#125; if (read(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with child: next state&quot;); switch (s) &#123; case SYNC_CHILD_READY: // 接收孙进程任务完成消息 ready = true; break; default: bail(&quot;unexpected sync value: %u&quot;, s); &#125; &#125; // 退出。很明显，当前 runc init 退出的时候，子 runc init 一定也退出了， // 但是孙 runc init 还没有退出 // 这也是为什么容器外的 runc 等待子进程退出，却又向 pipe 里写数据的原因， // 因为孙 runc init 还在等着容器配置 // 进程正常退出（不给 go 代码执行的机会） exit(0);\t&#125; Child 子进程加入了 init pipe 传递的 namespaces 配置，unshare 设置了 user namespace，并通知 parent 对 usermap(uid&#x2F;gid map) 进行配置后，将当前容器的 uid 设置为 0 (root) ；最后创建将 fork 的 grantchild 进程pid发送给 parent 。 !FILENAME libcontainer&#x2F;nsenter&#x2F;nsexec.c:969 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495\t/* * Stage 1: We&#x27;re in the first child process. Our job is to join any * provided namespaces in the netlink payload and unshare all * of the requested namespaces. If we&#x27;ve been asked to * CLONE_NEWUSER, we will ask our parent (stage 0) to set up * our user mappings for us. Then, we create a new child * (stage 2: JUMP_INIT) for PID namespace. We then send the * child&#x27;s PID to our parent (stage 0). */ case JUMP_CHILD:&#123; pid_t child; enum sync_t s; syncfd = sync_child_pipe[0]; close(sync_child_pipe[1]); /* For debugging. */ prctl(PR_SET_NAME, (unsigned long)&quot;runc:[1:CHILD]&quot;, 0, 0, 0); // 通过 setns 加入现有的 namespaces if (config.namespaces) join_namespaces(config.namespaces); // 如果 clone flag 里有 CLONE_NEWUSER，说明需要创建新的 user namespace， // 使用 unshare() 创建 user namespace if (config.cloneflags &amp; CLONE_NEWUSER) &#123; if (unshare(CLONE_NEWUSER) &lt; 0) bail(&quot;failed to unshare user namespace&quot;); config.cloneflags &amp;= ~CLONE_NEWUSER; /* Switching is only necessary if we joined namespaces. */ if (config.namespaces) &#123; if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) &lt; 0) bail(&quot;failed to set process as dumpable&quot;); &#125; // 等待父 runc init 配置 user map // 发送 SYNC_USERMAP_PLS 消息给 parent ,并接收其 SYNC_USERMAP_ACK 确认消息 s = SYNC_USERMAP_PLS; if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with parent: write(SYNC_USERMAP_PLS)&quot;); if (read(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with parent: read(SYNC_USERMAP_ACK)&quot;); if (s != SYNC_USERMAP_ACK) bail(&quot;failed to sync with parent: SYNC_USERMAP_ACK: got %u&quot;, s); /* Switching is only necessary if we joined namespaces. */ if (config.namespaces) &#123; if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) &lt; 0) bail(&quot;failed to set process as dumpable&quot;); &#125; // 设置当前进程的 uid 为 0，即容器内的 root 用户 if (setresuid(0, 0, 0) &lt; 0) bail(&quot;failed to become root in user namespace&quot;); &#125; // 使用 unshare() 其他需要新建的 namespace if (unshare(config.cloneflags &amp; ~CLONE_NEWCGROUP) &lt; 0) bail(&quot;failed to unshare namespaces&quot;); // 创建孙进程，当前进程已经完成了 namespace 的设置，孙进程会继承这些设置 child = clone_parent(&amp;env, JUMP_INIT); if (child &lt; 0) bail(&quot;unable to fork: init_func&quot;); // 将孙进程 PID 传给 parent 消息&quot; SYNC_RECVPID_PLS + Grandchild_pid &quot; s = SYNC_RECVPID_PLS; if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with parent: write(SYNC_RECVPID_PLS)&quot;); &#125; if (write(syncfd, &amp;child, sizeof(child)) != sizeof(child)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with parent: write(childpid)&quot;); &#125; // 等待父 runc init 接收PID 确认消息&quot; SYNC_RECVPID_ACK &quot; if (read(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with parent: read(SYNC_RECVPID_ACK)&quot;); &#125; if (s != SYNC_RECVPID_ACK) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with parent: SYNC_RECVPID_ACK: got %u&quot;, s); &#125; // 发送 SYNC_CHILD_READY 给 parent , Child 任务已完成 s = SYNC_CHILD_READY; if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) &#123; kill(child, SIGKILL); bail(&quot;failed to sync with parent: write(SYNC_CHILD_READY)&quot;); &#125; // 子 runc init 的工作到此结束，进程正常退出（不给 go 代码执行的机会） exit(0);\t&#125; Grandchild (final child) 孙进程是真正启动容器 entrypoint 的 init 进程，并且在启动之前，进行最后的环境准备工作(sid、uid、gid、cgroup namespace)，执行完成后return 至 init Go runtime 代码处继续执行。 !FILENAME libcontainer&#x2F;nsenter&#x2F;nsexec.c:969 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 /* * Stage 2: We&#x27;re the final child process, and the only process that will * actually return to the Go runtime. Our job is to just do the * final cleanup steps and then return to the Go runtime to allow * init_linux.go to run. */\tcase JUMP_INIT:&#123; // enum sync_t s; syncfd = sync_grandchild_pipe[0]; close(sync_grandchild_pipe[1]); close(sync_child_pipe[0]); close(sync_child_pipe[1]); /* For debugging. */ prctl(PR_SET_NAME, (unsigned long)&quot;runc:[2:INIT]&quot;, 0, 0, 0); // 等待（读取pipe） parent(祖父) 进程的 SYNC_GRANDCHILD 准备运行消息 if (read(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with parent: read(SYNC_GRANDCHILD)&quot;); if (s != SYNC_GRANDCHILD) bail(&quot;failed to sync with parent: SYNC_GRANDCHILD: got %u&quot;, s); // 设置sid if (setsid() &lt; 0) bail(&quot;setsid failed&quot;); // 设置uid root if (setuid(0) &lt; 0) bail(&quot;setuid failed&quot;); // 设置gid root if (setgid(0) &lt; 0) bail(&quot;setgid failed&quot;); if (!config.is_rootless_euid &amp;&amp; config.is_setgroup) &#123; if (setgroups(0, NULL) &lt; 0) bail(&quot;setgroups failed&quot;); &#125; // 等待来自容器外 runc 的 child pipe 的关于 cgroup namespace 的消息 0x80（CREATECGROUPNS） if (config.cloneflags &amp; CLONE_NEWCGROUP) &#123; uint8_t value; // 从 pipenum 读取，请注意此处还从 bootstrap 进程通迅 pipe 获取配置 if (read(pipenum, &amp;value, sizeof(value)) != sizeof(value)) bail(&quot;read synchronisation value failed&quot;); if (value == CREATECGROUPNS) &#123; // 使用 unshare() 创建 cgroup namespace if (unshare(CLONE_NEWCGROUP) &lt; 0) bail(&quot;failed to unshare cgroup namespace&quot;); &#125; else bail(&quot;received unknown synchronisation value&quot;); &#125; // 发送孙进程准备完成的消息给 parent, 此消息发送后 parent 进程接收后已完成其全部任务退出 s = SYNC_CHILD_READY; if (write(syncfd, &amp;s, sizeof(s)) != sizeof(s)) bail(&quot;failed to sync with patent: write(SYNC_CHILD_READY)&quot;); // 关闭资源 /* Close sync pipes. */ close(sync_grandchild_pipe[0]); /* Free netlink data. */ nl_free(&amp;config); // 父/祖父 runc init 都退出了 // return，然后开始执行 go 代码 return; &#125;\tdefault: bail(&quot;unexpected jump value&quot;);\t&#125;\t/* Should never be reached. */\tbail(&quot;should never be reached&quot;);&#125; 此时代码已 return 回到了 runC init 命令的 go 代码继续执行，执行的进程空间仍是已完成 namespace 配置后的最后的进程(即 grandchild 进程在容器流程中称为 init 进程)，后面的init go执行流程本文前面已有简单介绍，更详细的执行流程分析可参照《RunC 源码通读指南之 Run》。 相关文档： 《RunC 源码通读指南之 Run》 《RunC 源码通读指南之 Create &amp; Start》 《RunC 源码通读指南之 Cgroup》 《RunC 源码通读指南之 Networks》 本文 END","tags":["docker","runc"],"categories":["技术文档","docker源码分析","RunC"]},{"title":"RunC 源码通读指南之 Cgroup","path":"/2023/01/16/RunC_Cgroup/","content":"概述Runc 作为 OCI 运行时标准的实现版本工具，其继承早期版本 Docker 的核心库 libcontainer 来 实现的 linux 系统层的资源隔离 、限制及控制等功能。Docker 容器技术通过利用 linux 的内核特性功能 cgroup 来限制与控制 container 的资源使用。本文将通过对 Runc 的 Cgroup 相关源码解析揭开如何对 cgroup 利用与实现对容器资源管控的面纱。linux 系统层的 cgroup 的基础知识本文将不做过多的介绍，请参考。 Runc 支持两种 cgroup driver: 一种是 cgroupfs ,一种是 systemd，在 runc 源码目录上也可以看到相应的两个目录 fs 和 systemd。而 kubelet 指定的 cgroup driver 为 cgroupfs,我们本文也仅关注于 cgroupfs 的分析,代码文件libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go 为实现 cgroupfs Manager管理操作。更多关于 cgroup 文件、目录详细说明可参考本文后的附录一。 linux 系统默认情况下将 mount cgroupfs 目录” &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F; “和” &#x2F;proc&#x2F;$pid&#x2F;cgroup “两个目录下操作实现对 进程的资源限制。对于 cgroupfs 文件系统操作方式也同样是 runC 实现的 cgroup 操作的关键接口所在,这也是runC对Cgroup操作根本原理所在。 本文先从 runc 执行过程中涉及 cgroup 的初始化、配置、应用的整个相关的过程分析,如要了解完整的 container run 的所有详细执行过程可参考本套 RunC 系列文档《 RunC 源码通读指南之 Run 》，本文仅指出执行流程中与 cgroup 相关初始化及应用的过程。其后分析了cgroup manager 和 subsystem 的实现详细分析，其实就是对 cgroup 的 CRUD 操作实现细节。最后在附录内附有 cgroup包的文件说明、公共 utils 方法功能解析说明以及各 subsystem 限制资源配置项的用途说明。 RunC 执行流程与 cgroup 的应用Container 的创建过程由 factory 调用 create 方法实现，在创建 factory 对象时指定了NewCgroupsManage func，在 factory 创建 container 时调用 func 为容器配置了fs.Manager对象。调用过程 runc create 命令创建容器开始: startContainer() &#x3D;&gt; createContainer() &#x3D;&gt; loadFactory() &#x3D;&gt; libcontainer.New() !FILENAME libcontainer&#x2F;factory_linux.go:131 12345678910111213func New(root string, options ...func(*LinuxFactory) error) (Factory, error) &#123; //...\tl := &amp;LinuxFactory&#123; Root: root, InitPath: &quot;/proc/self/exe&quot;, InitArgs: []string&#123;os.Args[0], &quot;init&quot;&#125;, Validator: validate.New(), CriuPath: &quot;criu&quot;,\t&#125;\tCgroupfs(l) //为LinuxFactory配置NewCgroupsManage实现func\t//...\treturn l, nil&#125; 初始化配置LinuxFactory对象的NewCgroupsManage的func赋值，func将根据参数配置返回一个fs.Manager对象 !FILENAME libcontainer&#x2F;factory_linux.go:65 123456789101112// Cgroupfs is an options func to configure a LinuxFactory to return containers// that use the native cgroups filesystem implementation to create and manage// cgroups.func Cgroupfs(l *LinuxFactory) error &#123;\tl.NewCgroupsManager = func(config *configs.Cgroup, paths map[string]string) cgroups.Manager &#123; return &amp;fs.Manager&#123; Cgroups: config, Paths: paths, &#125;\t&#125;\treturn nil&#125; 创建 Container 容器对象，返回 linuxContainer 结构。LinuxFactory.NewCgroupsManager() 调用根据全局 config 赋值并返回 Cgroup Manager 对象 fs.Manger !FILENAME libcontainer&#x2F;factory_linux.go:188 12345678910111213141516func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) &#123; //...\tc := &amp;linuxContainer&#123; id: id, root: containerRoot, config: config, initPath: l.InitPath, initArgs: l.InitArgs, criuPath: l.CriuPath, newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, cgroupManager: l.NewCgroupsManager(config.Cgroups, nil), //为容器指定fs.Manager\t&#125; //...\treturn c, nil&#125; 从容器的执行流程来看，此时已完成 container 对象的创建，接下来startContainer()中已创建的 runner 对象 run() 方法执行，容器进入运行阶段。执行流程runc run命令：runner.run() &#x3D;&gt; newProcess() &#x3D;&gt; runner.container.Run(process) &#x3D;&gt; linuxContainer.strat() &#x3D;&gt; linuxContainer.newParentProcess(process) &#x3D;&gt; &#x3D;&gt;linuxContainer.commandTemplate() &#x3D;&gt; linuxContaine.newInitProcess() &#x3D;&gt;parent.start() &#x3D;&gt; initProcess.start() 。 Parent.start() 执行其实则是 runc init 命令的执行,其基本的执行流程(详细请参考《 RunC 源码通读指南之 Run 》)： parentproces 创建runc init子进程，中间会被 &#x2F;runc&#x2F;libcontainer&#x2F;nsenter 劫持(c代码部分preamble)，使 runc init 子进程位于容器配置指定的各个 namespace 内 parentProcess 用init管道将容器配置信息传输给runc init进程，runc init再据此进行容器的初始化操作。初始化完成之后，再向另一个管道exec.fifo进行写操作，进入阻塞状态 InitProcess.start()执行过程中对cgroup 资源组的配置与应用工作 !FILENAME libcontainer&#x2F;process_linux.go:282 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586func (p *initProcess) start() error &#123;\tdefer p.messageSockPair.parent.Close() // 当前执行空间进程称为bootstrap进程 // 启动了 cmd，即启动了 runc init 命令,创建 runc init 子进程 // 同时也激活了C代码nsenter模块的执行（为了 namespace 的设置 clone 了三个进程parent、child、init） // C 代码执行后返回 go 代码部分,最后的 init 子进程为了好区分此处命名为&quot; nsInit &quot;（即配置了Namespace的init） // runc init go代码为容器初始化其它部分(网络、rootfs、路由、主机名、console、安全等)\terr := p.cmd.Start() // runc init //... // 为进程 runc init 应用 Cgroup （p.cmd.Process.Pid()）\tif err := p.manager.Apply(p.pid()); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying cgroup configuration for process&quot;)\t&#125; //... // messageSockPair 管道写入 bootstrapData if _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != nil &#123; return newSystemErrorWithCause(err, &quot;copying bootstrap data to pipe&quot;)\t&#125; // 获取 nsInit pid\tchildPid, err := p.getChildPid()\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;getting the final child&#x27;s pid from pipe&quot;)\t&#125; //... // 为 nsInit 进程应用 Cgroup if err := p.manager.Apply(childPid); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying cgroup configuration for process&quot;)\t&#125; // 为 child 进程应用 intel RDT if p.intelRdtManager != nil &#123; if err := p.intelRdtManager.Apply(childPid); err != nil &#123; return newSystemErrorWithCause(err, &quot;applying Intel RDT configuration for process&quot;) &#125;\t&#125; //... // 解析runc init子进程的所有同步消息，当io.EOF返回\tierr := parseSync(p.messageSockPair.parent, func(sync *syncT) error &#123; switch sync.Type &#123; case procReady: // prestart hooks 启动前执行勾子 if !p.config.Config.Namespaces.Contains(configs.NEWNS) &#123; // 根据全局配置设置Cgroup if err := p.manager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting cgroup config for ready process&quot;) &#125; //... // 运行执行前勾子 for i, hook := range p.config.Config.Hooks.Prestart &#123; if err := hook.Run(s); err != nil &#123; return newSystemErrorWithCausef(err, &quot;running prestart hook %d&quot;, i) &#125; &#125; &#125; &#125; // 与子进程 runC init 同步 if err := writeSync(p.messageSockPair.parent, procRun); err != nil &#123; return newSystemErrorWithCause(err, &quot;writing syncT &#x27;run&#x27;&quot;) &#125; sentRun = true case procHooks: // 配置 cgroup if err := p.manager.Set(p.config.Config); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting cgroup config for procHooks process&quot;) &#125; //... if p.config.Config.Hooks != nil &#123; //... // 执行勾子定义任务 // 与子进程 runc-init 同步 &#125; sentResume = true default: return newSystemError(fmt.Errorf(&quot;invalid JSON payload from child&quot;)) &#125; return nil\t&#125;) //...\treturn nil&#125; 从整个执行过程来看，容器 init go 代码运行初始化配置后向exec.fifo管道写数据，阻塞，直到用户调用runc start，读取管道中的数据将最后执行用户定义的entrypoint程序。 上面已为Cgroup在容器创建过程中的配置与应用的管理过程，而接下来我们将看看底层是如何实现cgroup的。 Cgroup manager 实现Cgroup manger 为 Runc 实现对系统的 cgroup 操作的管理器抽象。manger对象实现对 cgroup 的配置项值设置、pid应用、销毁 、暂停&#x2F;恢复、获取配置等操作。这里Apply() 和 Set() 注意一下两者的差别，一个是设置子系统的相关资源约束项的值，一个是将进程pid操作应用至相关的cgroup子系统。 我们先来查看几个关键接口、结构体定义： cgroup manager接口定义 !FILENAME libcontainer&#x2F;cgroups&#x2F;cgroups.go:11 123456789101112131415161718type Manager interface &#123; // 为指定的 pid 应用 cgroup 配置\tApply(pid int) error\t// 返回 cgroup 集内所有 pid\tGetPids() ([]int, error) // 返回 cgroup 集和 subcgroups 的所有 pid\tGetAllPids() ([]int, error) // 返回 cgroup 集统计信息\tGetStats() (*Stats, error)\t// 任务暂停与恢复操作\tFreeze(state configs.FreezerState) error // 销毁 cgroup 集\tDestroy() error // 获取保存 cgroup 状态文件路径\tGetPaths() map[string]string\t// 设置 Cgroup 配置值\tSet(container *configs.Config) error // +configs.Config 容器进程配置结构&#125; Configs.Config 容器进程配置的结构体内 cgroups 相关定义 !FILENAME libcontainer&#x2F;configs&#x2F;config.go:81 123456789// 定义容器内执行进程的配置项，此处仅关注 Cgroup 相关type Config struct &#123; //... // 容器的 Cgroups 资源限制配置\tCgroups *Cgroup `json:&quot;cgroups&quot;` //+Cgroup 结构 // .... // 当 RootlessCgroups 设置为 true,cgroups 错误将被忽略\tRootlessCgroups bool `json:&quot;rootless_cgroups,omitempty&quot;`&#125; Configs.cgroups 的结构定义 !FILENAME libcontainer&#x2F;configs&#x2F;cgroup_linux.go:11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354type Cgroup struct &#123;\t// Deprecated, use Path instead\tName string `json:&quot;name,omitempty&quot;` // name of parent of cgroup or slice\t// Deprecated, use Path instead\tParent string `json:&quot;parent,omitempty&quot;` // Path指定由容器创建(和/或)连接的cgroup的路径。假定路径相对于主机系统cgroup挂载点。\tPath string `json:&quot;path&quot;`\t// ScopePrefix describes prefix for the scope name\tScopePrefix string `json:&quot;scope_prefix&quot;`\t// Paths represent the absolute cgroups paths to join.\t// This takes precedence over Path.\tPaths map[string]string\t// 资源包含各种Cgroup的应用设置\t*Resources // +参考下面定义&#125; // 每项详细说明参考本文附录一type Resources struct &#123;\tAllowAllDevices *bool `json:&quot;allow_all_devices,omitempty&quot;`\tAllowedDevices []*Device `json:&quot;allowed_devices,omitempty&quot;`\tDeniedDevices []*Device `json:&quot;denied_devices,omitempty&quot;`\tDevices []*Device `json:&quot;devices&quot;`\tMemory int64 `json:&quot;memory&quot;`\tMemoryReservation int64 `json:&quot;memory_reservation&quot;`\tMemorySwap int64 `json:&quot;memory_swap&quot;`\tKernelMemory int64 `json:&quot;kernel_memory&quot;`\tKernelMemoryTCP int64 `json:&quot;kernel_memory_tcp&quot;`\tCpuShares uint64 `json:&quot;cpu_shares&quot;`\tCpuQuota int64 `json:&quot;cpu_quota&quot;`\tCpuPeriod uint64 `json:&quot;cpu_period&quot;`\tCpuRtRuntime int64 `json:&quot;cpu_rt_quota&quot;`\tCpuRtPeriod uint64 `json:&quot;cpu_rt_period&quot;`\tCpusetCpus string `json:&quot;cpuset_cpus&quot;`\tCpusetMems string `json:&quot;cpuset_mems&quot;`\tPidsLimit int64 `json:&quot;pids_limit&quot;`\tBlkioWeight uint16 `json:&quot;blkio_weight&quot;`\tBlkioLeafWeight uint16 `json:&quot;blkio_leaf_weight&quot;`\tBlkioWeightDevice []*WeightDevice `json:&quot;blkio_weight_device&quot;`\tBlkioThrottleReadBpsDevice []*ThrottleDevice `json:&quot;blkio_throttle_read_bps_device&quot;`\tBlkioThrottleWriteBpsDevice []*ThrottleDevice `json:&quot;blkio_throttle_write_bps_device&quot;`\tBlkioThrottleReadIOPSDevice []*ThrottleDevice `json:&quot;blkio_throttle_read_iops_device&quot;`\tBlkioThrottleWriteIOPSDevice []*ThrottleDevice `json:&quot;blkio_throttle_write_iops_device&quot;`\tFreezer FreezerState `json:&quot;freezer&quot;`\tHugetlbLimit []*HugepageLimit `json:&quot;hugetlb_limit&quot;`\tOomKillDisable bool `json:&quot;oom_kill_disable&quot;`\tMemorySwappiness *uint64 `json:&quot;memory_swappiness&quot;`\tNetPrioIfpriomap []*IfPrioMap `json:&quot;net_prio_ifpriomap&quot;`\tNetClsClassid uint32 `json:&quot;net_cls_classid_u&quot;`&#125; Runc 代码在 Manager 接口的实现类有两个版本driver,一个实现类 fs.Manager ,一个是 systemd.Manager ，本文主要分析 cgroupfs 驱动即 fs.Manager 的实现代码。 我们先看一下 fs.Manager 的定义 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:65 123456type Manager struct &#123;\tmu sync.Mutex\tCgroups *configs.Cgroup // 全局配置的 cgroup 项定义（configs.Cgroup前面有结构体说明）\tRootless bool Paths map[string]string // 存放子系统名与路径&#125; cgroupData cgroup 配置数据定义 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:98 123456type cgroupData struct &#123;\troot string // cgroup 根路径\tinnerPath string // 指定由容器创建(和/或)连接的cgroup的路径\tconfig *configs.Cgroup // Cgroup 全局配置项\tpid int // 进程id&#125; manager.Apply() 将指定的 pid 应用资源的限制 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:132 12345678910111213141516171819202122232425262728293031323334353637func (m *Manager) Apply(pid int) (err error) &#123;\tif m.Cgroups == nil &#123; // 全局 cgroup 配置是否存在检测 return nil\t&#125; //...\tvar c = m.Cgroups\td, err := getCgroupData(m.Cgroups, pid) // +获取与构建 cgroupData 对象 //...\tm.Paths = make(map[string]string) // 如果全局配置存在 cgroup paths 配置，\tif c.Paths != nil &#123; for name, path := range c.Paths &#123; _, err := d.path(name) // 查找子系统的 cgroup path 是否存在 if err != nil &#123; if cgroups.IsNotFound(err) &#123; continue &#125; return err &#125; m.Paths[name] = path &#125; return cgroups.EnterPid(m.Paths, pid) // 将 pid 写入子系统的 cgroup.procs 文件\t&#125; // 遍历所有 cgroup 子系统,将配置应用 cgroup 资源限制\tfor _, sys := range subsystems &#123; p, err := d.path(sys.Name()) // 查找子系统的 cgroup path if err != nil &#123; //... return err &#125; m.Paths[sys.Name()] = p if err := sys.Apply(d); err != nil &#123; // 各子系统 apply() 方法调用 //...\t&#125;\treturn nil&#125; 获取与构建 cgroupData 对象 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:291 1234567891011121314func getCgroupData(c *configs.Cgroup, pid int) (*cgroupData, error) &#123;\troot, err := getCgroupRoot() // +获取cgroup root根目录\tif err != nil &#123; return nil, err\t&#125; //...\treturn &amp;cgroupData&#123; root: root, innerPath: innerPath, config: c, pid: pid,\t&#125;, nil&#125; cgroupRoot 全局变量为空则通过查找” &#x2F;proc&#x2F;self&#x2F;mountinfo “满足条件为” filesystem 列为 cgroup “的挂载点目录，则为 cgroup 的根目录 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:77 1234567891011121314151617181920func getCgroupRoot() (string, error) &#123;\tcgroupRootLock.Lock()\tdefer cgroupRootLock.Unlock()\tif cgroupRoot != &quot;&quot; &#123; return cgroupRoot, nil\t&#125;\troot, err := cgroups.FindCgroupMountpointDir() // 查找&quot;/proc/self/mountinfo&quot;挂载点目录\tif err != nil &#123; return &quot;&quot;, err\t&#125;\tif _, err := os.Stat(root); err != nil &#123; //判断是否存在 return &quot;&quot;, err &#125;\tcgroupRoot = root\treturn cgroupRoot, nil&#125; manager.Set() 根据容器的全局配置 Config 的 Cgroups 资源限制项，将 configs 写入至 cgroup 子系统文件 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:282 1234567891011func (m *Manager) Set(container *configs.Config) error &#123; //...\tpaths := m.GetPaths() // 遍历所有子系统，设置容器的全局配置 Config 的 Cgroups 资源限制项\tfor _, sys := range subsystems &#123; path := paths[sys.Name()] if err := sys.Set(path, container.Cgroups); err != nil &#123; //...\t&#125;\treturn nil&#125; manager.Freeze() 根据容器的全局 configs 配置应用 cgroup 暂停与恢复操作状态值 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go:264 123456789101112func (m *Manager) Freeze(state configs.FreezerState) error &#123;\tpaths := m.GetPaths()\tdir := paths[&quot;freezer&quot;] // 获取子系统的 path\tprevState := m.Cgroups.Resources.Freezer\tm.Cgroups.Resources.Freezer = state\tfreezer, err := subsystems.Get(&quot;freezer&quot;) if err != nil &#123; return err\t&#125;\terr = freezer.Set(dir, m.Cgroups) // 设置 state 状态值 //...&#125; 其它 manager 方法：manager.GetPids() &#x2F;manager.GetAllPids() &#x2F; manager.GetPaths() &#x2F; manager.Destroy() &#x2F; manager.GetStats() 略 Cgroup subsystem 实现Cgroupfs 子系统接口、关键类型、关键全局变量定义 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;apply_raw.go 1234567891011121314151617181920212223242526272829303132333435// 子系统接口定义type subsystem interface &#123; // 返回子系统的名称\tName() string\t// 返回cgroup stats状态\tGetStats(path string, stats *cgroups.Stats) error\t// 移除cgroup\tRemove(*cgroupData) error // 创建和加入cgroup\tApply(*cgroupData) error\t// 设置cgroup配置项值\tSet(path string, cgroup *configs.Cgroup) error&#125;// 子系统集类型定义type subsystemSet []subsystem// subsystems全局变量定义了支持的子系统列表；// &quot;&amp;CpusetGroup&#123;&#125;...&quot;都为subsystem接口的具体实现var (\tsubsystems = subsystemSet&#123; &amp;CpusetGroup&#123;&#125;, &amp;DevicesGroup&#123;&#125;, &amp;MemoryGroup&#123;&#125;, &amp;CpuGroup&#123;&#125;, &amp;CpuacctGroup&#123;&#125;, &amp;PidsGroup&#123;&#125;, &amp;BlkioGroup&#123;&#125;, &amp;HugetlbGroup&#123;&#125;, &amp;NetClsGroup&#123;&#125;, &amp;NetPrioGroup&#123;&#125;, &amp;PerfEventGroup&#123;&#125;, &amp;FreezerGroup&#123;&#125;, &amp;NameGroup&#123;GroupName: &quot;name=systemd&quot;, Join: true&#125;,\t&#125; “cgroups&#x2F;fs&#x2F;“ 目录下包含了各种支持的子系统实现代码，下面我们用 cpu subsystem 的实现代码详细分析作为代表，其它子系统的实现逻辑类似，本文将不作详细的一一分析。 “cgroups&#x2F;fs&#x2F;cpu.go” 文件内包含了 cpu subsystem 的实现代码： CpuGroup.Name() 获取 cpu 子系统名称 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:18 123func (s *CpuGroup) Name() string &#123;\treturn &quot;cpu&quot;&#125; CpuGroup.Apply() 基于 Cgroup configs 设置项，应用 CPU 资源限制 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:22 1234567func (s *CpuGroup) Apply(d *cgroupData) error &#123;\tpath, err := d.path(&quot;cpu&quot;)\tif err != nil &amp;&amp; !cgroups.IsNotFound(err) &#123; return err\t&#125;\treturn s.ApplyDir(path, d.config, d.pid) // +创建目录和pid写cgroup.procs文件应用cpu限制&#125; 创建目录和 pid 写入 cgroup.procs 文件应用 cpu 限制 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:32 123456789101112131415func (s *CpuGroup) ApplyDir(path string, cgroup *configs.Cgroup, pid int) error &#123;\tif path == &quot;&quot; &#123; return nil\t&#125; // 创建目录\tif err := os.MkdirAll(path, 0755); err != nil &#123; return err\t&#125; // 设置 RT(realtime)调度值： cpu.rt_period_us ，cpu.rt_runtime_us\tif err := s.SetRtSched(path, cgroup); err != nil &#123; return err\t&#125; // pid加入cgroup procs文件应用cgroup组限制\treturn cgroups.WriteCgroupProc(path, pid)&#125; CpuGroup.Set() 基于 Cgroup configs 设置项，写入配置值至相应的子系统控制资源文件，实现 CPU 的限制调节 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:66 12345678910111213141516171819202122func (s *CpuGroup) Set(path string, cgroup *configs.Cgroup) error &#123;\tif cgroup.Resources.CpuShares != 0 &#123; // 写入文件值，控制cgroup组之间的配额占比 if err := writeFile(path, &quot;cpu.shares&quot;, strconv.FormatUint(cgroup.Resources.CpuShares, 10)); err != nil &#123; return err &#125;\t&#125;\tif cgroup.Resources.CpuPeriod != 0 &#123; // 写入文件值，CFS调度 CPU 时间的周期 if err := writeFile(path, &quot;cpu.cfs_period_us&quot;, strconv.FormatUint(cgroup.Resources.CpuPeriod, 10)); err != nil &#123; return err &#125;\t&#125;\tif cgroup.Resources.CpuQuota != 0 &#123; // 写入文件值，CFS调度 期间内可使用的 cpu 时间 if err := writeFile(path, &quot;cpu.cfs_quota_us&quot;, strconv.FormatInt(cgroup.Resources.CpuQuota, 10)); err != nil &#123; return err &#125;\t&#125; // 设置 RT(realtime)调度值： cpu.rt_period_us ，cpu.rt_runtime_us\treturn s.SetRtSched(path, cgroup)&#125; CpuGroup.GetStats() 获取子系统的 cpu.stat 状态文件信息 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:89 1234567891011121314151617181920212223242526272829func (s *CpuGroup) GetStats(path string, stats *cgroups.Stats) error &#123;\tf, err := os.Open(filepath.Join(path, &quot;cpu.stat&quot;)) // cpu.stat文件\tif err != nil &#123; if os.IsNotExist(err) &#123; return nil &#125; return err\t&#125;\tdefer f.Close()\tsc := bufio.NewScanner(f)\tfor sc.Scan() &#123; t, v, err := getCgroupParamKeyValue(sc.Text()) // K/V解析 if err != nil &#123; return err &#125; switch t &#123; case &quot;nr_periods&quot;: //&quot;nr_periods&quot; 进入周期的次数 stats.CpuStats.ThrottlingData.Periods = v case &quot;nr_throttled&quot;: //&quot;nr_throttled&quot; 运行时间被调整的次数 stats.CpuStats.ThrottlingData.ThrottledPeriods = v case &quot;throttled_time&quot;: //&quot;throttled_time&quot; 用于调整的时间 stats.CpuStats.ThrottlingData.ThrottledTime = v &#125;\t&#125;\treturn nil&#125; CpuGroup.remove() 删除 cpu 子系统 !FILENAME libcontainer&#x2F;cgroups&#x2F;fs&#x2F;cpu.go:85 123func (s *CpuGroup) Remove(d *cgroupData) error &#123;\treturn removePath(d.path(&quot;cpu&quot;)) //删除path&#125; 其它 cgroup 的子系统资源设置项说明可参考后面的附录。 附录 一Cgroup 包内文件说明123456789101112131415161718192021222324252627282930313233343536373839404142├── cgroups.go ----------------------------&gt;| 定义cgroup Manager接口操作 ├── cgroups_test.go├── cgroups_unsupported.go├── fs│ ├── apply_raw.go ----------------------------&gt;| cgroupfs driver Manager实现 │ ├── apply_raw_test.go │ ├── blkio.go -------[blkio子系统]---------&gt;|│ ├── blkio_test.go |│ ├── cpu.go -------[cpu子系统]-----------&gt;|│ ├── cpu_test.go | │ ├── cpuacct.go -------[cpuacct子系统]-------&gt;|│ ├── cpuset.go -------[cpuset子系统]--------&gt;|│ ├── cpuset_test.go | │ ├── devices.go -------[devices子系统]-------&gt;|\\│ ├── devices_test.go | |\\ 各子系统实现，Cgroupfs目录文件│ ├── freezer.go -------[freezer子系统]-------&gt;| |/ 的CRUD方法│ ├── freezer_test.go |/│ ├── fs_unsupported.go |│ ├── hugetlb.go -------[hugetlb子系统]-------&gt;|│ ├── hugetlb_test.go |│ ├── kmem.go |│ ├── kmem_disabled.go |│ ├── memory.go -------[memory子系统]--------&gt;|│ ├── memory_test.go |│ ├── name.go -------[systemd子系统]-------&gt;|│ ├── net_cls.go -------[netcls子系统]--------&gt;|│ ├── net_cls_test.go |│ ├── net_prio.go -------[netprio子系统]-------&gt;|│ ├── net_prio_test.go |│ ├── perf_event.go -------[perf event子系统]----&gt;|│ ├── pids.go -------[pid子系统]-----------&gt;|│ ├── pids_test.go│ ├── stats_util_test.go│ ├── util_test.go │ ├── utils.go ----------------------------&gt;| fs包内共享的工具方法│ └── utils_test.go├── stats.go ----------------------------&gt;| cgroup stats 定义与对象构建├── systemd│ ├── apply_nosystemd.go│ └── apply_systemd.go ----------------------------&gt;| cgroup systemd driver manager 实现 ├── utils.go ----------------------------&gt;| 包内共享的工具方法└── utils_test.go Cgroup 子系统资源配置项相关说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. [pids] --- 限制cgroup及其所有子孙cgroup里面能创建的总的task数量 pids.max 所允许创建的总的最大进程数量 pids.current 现有的总的进程数量2. [memory] --- 限制内存子系统限制内存使用量 memory.memsw.limit_in_bytes 内存＋swap空间使用的总量限制 memory.limit_in_bytes 内存使用量限制 memory.kmem.limit_in_bytes 限制内核使用的内存大小 memory.soft_limit_in_bytes 内存软限制 memory.kmem.tcp.limit_in_bytes 设置tcp 缓存内存的hard limit memory.oom_control 设置/读取内存超限控制信息 memory.swappiness 用来调整cgroup使用swap的状态，表示不使用交换分区3. [cpu] --- 限制进程的cpu总体占用率 cpu.rt_period_us 实时任务统计CPU使用时间的周期 cpu.rt_runtime_us 实时任务周期内允许任务使用单个CPU核的时间，如果系统中有多个核，则可以使用核倍数的时间 cpu.shares 控制各个cgroup组之间的配额占比 //下面两个组合使用，限制该组中的所有进程在单位时间里可以使用的 cpu 时间 //如:将 cpu.cfs_quota_us 设为 50000，相对于 cpu.cfs_period_us 的 100000 即 50% //cfs_quota_us 也是可以大于 cfs_period_us 的，这主要是对于多核情况 cpu.cfs_period_us 时间周期，默认为 100000，即百毫秒 cpu.cfs_quota_us 期间内可使用的 cpu 时间，默认 -1，即无限制4. [cpuset] --- 多核心的cpu环境，为cgroup任务分配独立的内存节点和CPU节点 cpuset.cpus 限制只能使用特定CPU节点 cpuset.mems 限制只能使用特定内存节点5. [devices] --- 以控制进程能够访问某些设备 // echo &quot;a 1:5 r&quot; &gt; devices.deny // a|b|C all/block/character // r|w|m read/write/create devices.deny 拒绝 devices.allow 允许6. [blkio] --- 设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及usb等等 // CFQ Completely Fair Queuing 完全公平队列 blkio.weight 权重值(范围100-1000) blkio.leaf_weight blkio.weight_device 块设备级的值 (major:minor weight) （优先级高于blkio.weight） blkio.leaf_weight_device // 限制IOPS使用上限 blkio.throttle.read_bps_device 读设备 bytes/s blkio.throttle.write_bps_device 写设备 bytes/s blkio.throttle.read_iops_device 读设备 io/s blkio.throttle.write_iops_device 写设备 io/s 7. [net_prio] --- 配置每个网络接口的流量优先级 net_prio.ifpriomap 优先级图谱8. [net_cls] --- 标记每个网络包,可供QOS/netfilter使用 net_cls.classid 标签id9. [freezer] --- 暂停和恢复cgroup任务 freezer.state 当前的状态,两个状态是写有效(Frozen已冻结/Thawed解冻状态)10.[hugetlb] --- 对于HugeTLB系统进行限制，这是一个大页文件系统 hugetlb.XX.limit_in_bytes 限制大页字节数 附录 二cgroups 包下 utils 定义的方法用途简析 !FILENAME libcontainer&#x2F;cgroups&#x2F;utils.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 查找/proc/self/mountinfo下满足条件“cgroupPath，subsystem”的项，返回&quot;Cgroup根目录与挂载点&quot;func FindCgroupMountpointAndRoot(cgroupPath, subsystem string) (string, string, error) &#123;...&#125;func findCgroupMountpointAndRootFromReader(reader io.Reader, cgroupPath, subsystem string) (string, string, error) &#123;...&#125;// 获取&quot;/proc/self/cgroup&quot;进行匹配是否存在subsystemfunc isSubsystemAvailable(subsystem string) bool&#123;...&#125; // 查&quot;/proc/self/mountinfo&quot;满足条件&quot;filesystem列为cgroup&quot;的挂载点目录；// 一般为&quot;/sys/fs/cgroup/&quot;func FindCgroupMountpointDir() (string, error) &#123;...&#125;// 获取所有Cgroup信息结构化Mount slice返回；[]Mount&#123;Mountpoint/Root/Subsystems[]&#125;func GetCgroupMounts(all bool) ([]Mount, error) &#123;...&#125;func getCgroupMountsHelper(ss map[string]bool,mi io.Reader, all bool) ([]Mount, error) &#123;...&#125; // 打开/proc/&lt;pid&gt;/cgroup文件调用parseCgroupFromReader()func ParseCgroupFile(path string) (map[string]string, error) &#123;...&#125;// 解析&quot;/proc/[pid]/cgroup&quot;输出map[subsystem]cgroup-pathfunc parseCgroupFromReader(r io.Reader) (map[string]string, error) &#123;...&#125;// 返回subsystem的cgroup-pathfunc getControllerPath(subsystem string, cgroups map[string]string) (string, error) &#123;...&#125;// 获取当前进程的(root)Cgroup-path,通过解析&quot;/proc/self/cgroup&quot;文件func GetOwnCgroup(subsystem string) (string, error) &#123;...&#125;// 获取当前进程的(mnt)Cgroup-pathfunc GetOwnCgroupPath(subsystem string) (string, error) &#123;...&#125;// 获取init进程的(root)Cgroup-path,通过解析&quot;/proc/1/cgroup&quot;文件func GetInitCgroup(subsystem string) (string, error) &#123;...&#125;// 获取init进程的(mnt)Cgroup-pathfunc GetInitCgroupPath(subsystem string) (string, error) &#123;...&#125;// 获取Cgroup mnt pathfunc getCgroupPathHelper(subsystem, cgroup string) (string, error) &#123;...&#125;// 获取指定被加入cgroup path的所有pidfunc GetPids(path string) ([]int, error)&#123;...&#125;// 获取指定被加入cgroup path和subcgroups的所有pidfunc GetAllPids(path string) ([]int, error) &#123;...&#125;// 打开指定dir的cgroup subsystem的&quot;cgroup.procs&quot; 读取pidsfunc readProcsFile(dir string) ([]int, error) &#123;...&#125;// 写入指定的 pid 至 Cgroup subsystem &quot;cgroup.procs&quot;文件func EnterPid(cgroupPaths map[string]string, pid int) error// 打开指定dir的cgroup subsystem的&quot;cgroup.procs&quot;写入指定的pidfunc WriteCgroupProc(dir string, pid int) error &#123;...&#125;// 获取大页大小列表func GetHugePageSize() ([]string, error) &#123;...&#125;// 读&quot;/sys/kernel/mm/hugepages&quot;目录下文件，解析文件名获取hg大小func getHugePageSizeFromFilenames(fileNames []string) ([]string, error) &#123;...&#125; 相关文档： 《RunC 源码通读指南之 Run》 《RunC 源码通读指南之 Create &amp; Start》 《RunC 源码通读指南之 Namespace》 《RunC 源码通读指南之 Networks》 本文 END","tags":["docker","runc"],"categories":["技术文档","docker源码分析","RunC"]},{"title":"RunC 源码通读指南之 Run","path":"/2023/01/16/RunC_Run/","content":"概述RunC 工具与命令RunC 工具命令操作实例： 1234567891011121314151617181920# 1. 准备rootfs文件$&gt; mkdir /mycontainer; cd /mycontainer$&gt; docker export $(docker create busybox) | tar -C rootfs -xvf -# 2. 创建一个config.json文件(标准的OCI格式的文件)$&gt; runc spec # 3. rootfs和config.json都有了就可以创建容器$&gt; runc run $mycontainerid#---------------------------------## 容器的整个生命周期管理# 创建$&gt; runc create $mycontainerid# 启动$&gt; runc start $mycontainerid# 查看$&gt; runc list# 删除$&gt; runc delete $mycontainerid CLI 执行cli app的执行 !FILENAME run.go:65 1234567891011121314151617181920212223Action: func(context *cli.Context) error &#123; // 命令参数校验 if err := checkArgs(context, 1, exactArgs); err != nil &#123; return err &#125; // 获取&quot;pid-file&quot;传参配置，转化为绝对路径 if err := revisePidFile(context); err != nil &#123; return err &#125; // 读取 config.json spec, err := setupSpec(context) if err != nil &#123; return err &#125; // +startContainer() 启动容器 status, err := startContainer(context, spec, CT_ACT_RUN, nil) if err == nil &#123; // exit with the container&#x27;s exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) &#125; return err\t&#125;, startContainer() 启动容器 !FILENAME utils_linux.go:430 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) &#123; // 通过 spec 创建容器结构，在 createContainer 中将 spec 转换为了 runc 的 container config*\tid := context.Args().First() //命令行输入的container id参数\tif id == &quot;&quot; &#123; return -1, errEmptyID\t&#125;\tnotifySocket := newNotifySocket(context, os.Getenv(&quot;NOTIFY_SOCKET&quot;), id)\tif notifySocket != nil &#123; notifySocket.setupSpec(context, spec)\t&#125; // 创建容器对象\tcontainer, err := createContainer(context, id, spec) if err != nil &#123; return -1, err\t&#125;\tif notifySocket != nil &#123; err := notifySocket.setupSocket() if err != nil &#123; return -1, err &#125;\t&#125;\t// Support on-demand socket activation by passing file descriptors into the container init process.\tlistenFDs := []*os.File&#123;&#125;\tif os.Getenv(&quot;LISTEN_FDS&quot;) != &quot;&quot; &#123; listenFDs = activation.Files(false)\t&#125;\tlogLevel := &quot;info&quot;\tif context.GlobalBool(&quot;debug&quot;) &#123; logLevel = &quot;debug&quot;\t&#125; // 构建 runner 启动容器\tr := &amp;runner&#123; enableSubreaper: !context.Bool(&quot;no-subreaper&quot;), // shouldDestroy: true, // container: container, // 容器 listenFDs: listenFDs, // notifySocket: notifySocket, // consoleSocket: context.String(&quot;console-socket&quot;), // detach: context.Bool(&quot;detach&quot;), // pidFile: context.String(&quot;pid-file&quot;), // preserveFDs: context.Int(&quot;preserve-fds&quot;), // action: action, // CT_ACT_RUN criuOpts: criuOpts, // criu选项 init: true, // 用于设置 process.Init 字段 logLevel: logLevel, // 日志级别 default info\t&#125; return r.run(spec.Process) // run() 启动&#125; !FILENAME utils_linux.go:230 12345678910111213141516171819202122232425func createContainer(context *cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) &#123;\trootlessCg, err := shouldUseRootlessCgroupManager(context)\tif err != nil &#123; return nil, err\t&#125; // spec 转换 config\tconfig, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123; CgroupName: id, UseSystemdCgroup: context.GlobalBool(&quot;systemd-cgroup&quot;), NoPivotRoot: context.Bool(&quot;no-pivot&quot;), NoNewKeyring: context.Bool(&quot;no-new-keyring&quot;), Spec: spec, RootlessEUID: os.Geteuid() != 0, RootlessCgroups: rootlessCg,\t&#125;)\tif err != nil &#123; return nil, err\t&#125;\tfactory, err := loadFactory(context) //+ 创建配置工厂实例\tif err != nil &#123; return nil, err\t&#125;\treturn factory.Create(id, config) //+ 工厂实例化容器对象 &#125; !FILENAME utils_linux.go:31 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// loadFactory returns the configured factory instance for execing containers.func loadFactory(context *cli.Context) (libcontainer.Factory, error) &#123;\troot := context.GlobalString(&quot;root&quot;) abs, err := filepath.Abs(root) // 根目录绝对路径\tif err != nil &#123; return nil, err\t&#125;\tcgroupManager := libcontainer.Cgroupfs rootlessCg, err := shouldUseRootlessCgroupManager(context)\tif err != nil &#123; return nil, err\t&#125;\tif rootlessCg &#123; cgroupManager = libcontainer.RootlessCgroupfs\t&#125;\tif context.GlobalBool(&quot;systemd-cgroup&quot;) &#123; // systemd-cgroup if systemd.UseSystemd() &#123; cgroupManager = libcontainer.SystemdCgroups &#125; else &#123; return nil, fmt.Errorf(&quot;systemd cgroup flag passed, but systemd support for managing cgroups is not available&quot;) &#125;\t&#125;\tintelRdtManager := libcontainer.IntelRdtFs // intel RDT if !intelrdt.IsCatEnabled() &amp;&amp; !intelrdt.IsMbaEnabled() &#123; intelRdtManager = nil\t&#125;\t// We resolve the paths for &#123;newuidmap,newgidmap&#125; from the context of runc,\t// to avoid doing a path lookup in the nsexec context. TODO: The binary\t// names are not currently configurable.\tnewuidmap, err := exec.LookPath(&quot;newuidmap&quot;) // newuidmap\tif err != nil &#123; newuidmap = &quot;&quot;\t&#125;\tnewgidmap, err := exec.LookPath(&quot;newgidmap&quot;) // newgidmap\tif err != nil &#123; newgidmap = &quot;&quot;utils_linux.go\t&#125; // New factory\treturn libcontainer.New(abs, cgroupManager, intelRdtManager, libcontainer.CriuPath(context.GlobalString(&quot;criu&quot;)), libcontainer.NewuidmapPath(newuidmap), libcontainer.NewgidmapPath(newgidmap))&#125; !FILENAME libcontainer&#x2F;factory_linux.go:131 12345678910111213141516171819202122232425262728293031// New returns a linux based container factory based in the root directory and// configures the factory with the provided option funcs.func New(root string, options ...func(*LinuxFactory) error) (Factory, error) &#123;\tif root != &quot;&quot; &#123; if err := os.MkdirAll(root, 0700); err != nil &#123; //确保存储容器状态的根目录创建 return nil, newGenericError(err, SystemError) &#125;\t&#125;\tl := &amp;LinuxFactory&#123; // 存储容器状态的根目录，默认&quot;/run/runc/&quot; Root: root, // 指向当前的 exe 程序，即 runc 本身 InitPath: &quot;/proc/self/exe&quot;, // os.Args[0] 是当前 runc 的路径，本质上和 InitPath 是一样的，即 runc init InitArgs: []string&#123;os.Args[0], &quot;init&quot;&#125;, // Validator: validate.New(), // CriuPath: &quot;criu&quot;,\t&#125;\tCgroupfs(l) // cgroup配置\tfor _, opt := range options &#123; if opt == nil &#123; continue &#125; if err := opt(l); err != nil &#123; return nil, err &#125;\t&#125;\treturn l, nil&#125; !FILENAME libcontainer&#x2F;factory_linux.go:188 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) &#123; // 确保containerRoot目录被创建\tif l.Root == &quot;&quot; &#123; return nil, newGenericError(fmt.Errorf(&quot;invalid root&quot;), ConfigInvalid)\t&#125;\tif err := l.validateID(id); err != nil &#123; return nil, err\t&#125;\tif err := l.Validator.Validate(config); err != nil &#123; return nil, newGenericError(err, ConfigInvalid)\t&#125;\tcontainerRoot, err := securejoin.SecureJoin(l.Root, id)\tif err != nil &#123; return nil, err\t&#125;\tif _, err := os.Stat(containerRoot); err == nil &#123; return nil, newGenericError(fmt.Errorf(&quot;container with id exists: %v&quot;, id), IdInUse)\t&#125; else if !os.IsNotExist(err) &#123; return nil, newGenericError(err, SystemError)\t&#125;\tif err := os.MkdirAll(containerRoot, 0711); err != nil &#123; return nil, newGenericError(err, SystemError)\t&#125;\tif err := os.Chown(containerRoot, unix.Geteuid(), unix.Getegid()); err != nil &#123; return nil, newGenericError(err, SystemError)\t&#125; // 创建 linux 容器结构\tc := &amp;linuxContainer&#123; id: id, // 容器 ID root: containerRoot, // 容器状态文件存放目录，默认是 /run/runc/$容器ID/ config: config, // 容器配置 initPath: l.InitPath, // /proc/self/exe，就是runc initArgs: l.InitArgs, // 即runc init criuPath: l.CriuPath, // 热迁移path &quot;criu&quot; // Uid / Gid 配置 newuidmapPath: l.NewuidmapPath, newgidmapPath: l.NewgidmapPath, // cgroup配置 cgroupManager: l.NewCgroupsManager(config.Cgroups, nil),\t&#125; // 英特尔RDT（资源调配技术）配置\tif intelrdt.IsCatEnabled() || intelrdt.IsMbaEnabled() &#123; c.intelRdtManager = l.NewIntelRdtManager(config, id, &quot;&quot;)\t&#125;\tc.state = &amp;stoppedState&#123;c: c&#125; // 开始置为&quot;stopped&quot;状态\treturn c, nil&#125; utils_linux.go:271 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687func (r *runner) run(config *specs.Process) (int, error) &#123;\tvar err error\tdefer func() &#123; if err != nil &#123; r.destroy() &#125;\t&#125;()\tif err = r.checkTerminal(config); err != nil &#123; return -1, err\t&#125; // 基于config 创建process对象\tprocess, err := newProcess(*config, r.init, r.logLevel)\tif err != nil &#123; return -1, err\t&#125;\tif len(r.listenFDs) &gt; 0 &#123; process.Env = append(process.Env, fmt.Sprintf(&quot;LISTEN_FDS=%d&quot;, len(r.listenFDs)), &quot;LISTEN_PID=1&quot;) process.ExtraFiles = append(process.ExtraFiles, r.listenFDs...)\t&#125;\tbaseFd := 3 + len(process.ExtraFiles)\tfor i := baseFd; i &lt; baseFd+r.preserveFDs; i++ &#123; _, err = os.Stat(fmt.Sprintf(&quot;/proc/self/fd/%d&quot;, i)) if err != nil &#123; return -1, errors.Wrapf(err, &quot;please check that preserved-fd %d (of %d) is present&quot;, i-baseFd, r.preserveFDs) &#125; process.ExtraFiles = append(process.ExtraFiles, os.NewFile(uintptr(i), &quot;PreserveFD:&quot;+strconv.Itoa(i)))\t&#125;\trootuid, err := r.container.Config().HostRootUID()\tif err != nil &#123; return -1, err\t&#125;\trootgid, err := r.container.Config().HostRootGID()\tif err != nil &#123; return -1, err\t&#125;\tvar ( detach = r.detach || (r.action == CT_ACT_CREATE)\t)\t// Setting up IO is a two stage process. We need to modify process to deal\t// with detaching containers, and then we get a tty after the container has\t// started. // 处理io和tty相关配置\thandler := newSignalHandler(r.enableSubreaper, r.notifySocket)\ttty, err := setupIO(process, rootuid, rootgid, config.Terminal, detach, r.consoleSocket)\tif err != nil &#123; return -1, err\t&#125;\tdefer tty.Close()\tswitch r.action &#123;\tcase CT_ACT_CREATE: err = r.container.Start(process)\tcase CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts)\tcase CT_ACT_RUN: err = r.container.Run(process) // +调用linuxContainer.run()\tdefault: panic(&quot;Unknown action&quot;)\t&#125;\tif err != nil &#123; return -1, err\t&#125;\tif err = tty.waitConsole(); err != nil &#123; r.terminate(process) return -1, err\t&#125;\tif err = tty.ClosePostStart(); err != nil &#123; r.terminate(process) return -1, err\t&#125;\tif r.pidFile != &quot;&quot; &#123; if err = createPidFile(r.pidFile, process); err != nil &#123; r.terminate(process) return -1, err &#125;\t&#125;\tstatus, err := handler.forward(process, tty, detach)\tif err != nil &#123; r.terminate(process)\t&#125;\tif detach &#123; return 0, nil\t&#125;\tr.destroy()\treturn status, err&#125; libcontainer&#x2F;container_linux.go:250 123456789func (c *linuxContainer) Run(process *Process) error &#123;\tif err := c.Start(process); err != nil &#123; //+ return err\t&#125;\tif process.Init &#123; return c.exec() //+\t&#125;\treturn nil&#125; libcontainer&#x2F;container_linux.go:233 12345678910111213141516func (c *linuxContainer) Start(process *Process) error &#123;\tc.m.Lock()\tdefer c.m.Unlock()\tif process.Init &#123; if err := c.createExecFifo(); err != nil &#123; return err &#125;\t&#125;\tif err := c.start(process); err != nil &#123; //+ if process.Init &#123; c.deleteExecFifo() &#125; return err\t&#125;\treturn nil&#125; libcontainer&#x2F;container_linux.go:335 1234567891011121314151617181920212223242526272829303132333435363738394041424344func (c *linuxContainer) start(process *Process) error &#123; // process 是容器的 entrypoint，此处创建的是 entrypoint 的父进程\tparent, err := c.newParentProcess(process)\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;creating new parent process&quot;)\t&#125;\tparent.forwardChildLogs() //+ 启动父进程\tif err := parent.start(); err != nil &#123; // terminate the process to ensure that it properly is reaped. if err := ignoreTerminateErrors(parent.terminate()); err != nil &#123; logrus.Warn(err) &#125; return newSystemErrorWithCause(err, &quot;starting container process&quot;)\t&#125;\t// generate a timestamp indicating when the container was started\tc.created = time.Now().UTC()\tif process.Init &#123; c.state = &amp;createdState&#123; c: c, &#125; state, err := c.updateState(parent) if err != nil &#123; return err &#125; c.initProcessStartTime = state.InitProcessStartTime if c.config.Hooks != nil &#123; s, err := c.currentOCIState() if err != nil &#123; return err &#125; for i, hook := range c.config.Hooks.Poststart &#123; if err := hook.Run(s); err != nil &#123; if err := ignoreTerminateErrors(parent.terminate()); err != nil &#123; logrus.Warn(err) &#125; return newSystemErrorWithCausef(err, &quot;running poststart hook %d&quot;, i) &#125; &#125; &#125;\t&#125;\treturn nil&#125; libcontainer&#x2F;container_linux.go:441 1234567891011121314151617181920212223242526272829303132333435func (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) &#123; // 创建用于父子进程通信的 pipe\tparentInitPipe, childInitPipe, err := utils.NewSockPair(&quot;init&quot;)\tif err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;creating new init pipe&quot;)\t&#125;\tmessageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;\tparentLogPipe, childLogPipe, err := os.Pipe()\tif err != nil &#123; return nil, fmt.Errorf(&quot;Unable to create the log pipe: %s&quot;, err)\t&#125;\tlogFilePair := filePair&#123;parentLogPipe, childLogPipe&#125; // +创建父进程的 cmd\tcmd, err := c.commandTemplate(p, childInitPipe, childLogPipe) if err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;creating new command template&quot;)\t&#125;\tif !p.Init &#123; // 由于 p.Init 为 true，所以不会执行到这里 return c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) &#125;\t// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic\t// reason for this is that previously we would pass a dirfd that allowed\t// for container rootfs escape (and not doing it in `runc exec` avoided\t// that problem), but we no longer do that. However, there&#x27;s no need to do\t// this for `runc exec` so we just keep it this way to be safe.\tif err := c.includeExecFifo(cmd); err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;including execfifo in cmd.Exec setup&quot;)\t&#125; // +返回标准 init 进程\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair) &#125; 创建父进程的 cmd libcontainer&#x2F;container_linux.go:473 12345678910111213141516171819202122232425262728293031323334353637383940414243func (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) (*exec.Cmd, error) &#123; // 这里可以看到 cmd 就是 runc init\tcmd := exec.Command(c.initPath, c.initArgs[1:]...)\tcmd.Args[0] = c.initArgs[0] // 将设置给容器 entrypoint 的 std 流给了 runc init 命令，这些流最终会通过 runc init 传递给 entrypoint\tcmd.Stdin = p.Stdin\tcmd.Stdout = p.Stdout\tcmd.Stderr = p.Stderr\tcmd.Dir = c.config.Rootfs\tif cmd.SysProcAttr == nil &#123; cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;&#125;\t&#125;\tcmd.Env = append(cmd.Env, fmt.Sprintf(&quot;GOMAXPROCS=%s&quot;, os.Getenv(&quot;GOMAXPROCS&quot;)))\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\tif p.ConsoleSocket != nil &#123; cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket) cmd.Env = append(cmd.Env, fmt.Sprintf(&quot;_LIBCONTAINER_CONSOLE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1), )\t&#125; // 这个 childInitPipe 用于跟父进程通信（父进程就是当前这个 runc 进程）\tcmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe) // 通过环境变量 _LIBCONTAINER_INITPIPE 把 fd 号传递给 runc init，由于 std 流会占用前三个 fd 编号（0，1，2） // 所以 fd 要加上 3（stdioFdCount）\tcmd.Env = append(cmd.Env, fmt.Sprintf(&quot;_LIBCONTAINER_INITPIPE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1), fmt.Sprintf(&quot;_LIBCONTAINER_STATEDIR=%s&quot;, c.root),\t)\tcmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\tcmd.Env = append(cmd.Env, fmt.Sprintf(&quot;_LIBCONTAINER_LOGPIPE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1), fmt.Sprintf(&quot;_LIBCONTAINER_LOGLEVEL=%s&quot;, p.LogLevel),\t)\t// NOTE: when running a container with no PID namespace and the parent process spawning the container is\t// PID1 the pdeathsig is being delivered to the container&#x27;s init process by the kernel for some reason\t// even with the parent still running.\tif c.config.ParentDeathSignal &gt; 0 &#123; cmd.SysProcAttr.Pdeathsig = syscall.Signal(c.config.ParentDeathSignal)\t&#125;\treturn cmd, nil&#125; libcontainer&#x2F;container_linux.go:541 123456789101112131415161718192021222324func (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*setnsProcess, error) &#123;\tcmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_INITTYPE=&quot;+string(initSetns))\tstate, err := c.currentState()\tif err != nil &#123; return nil, newSystemErrorWithCause(err, &quot;getting container&#x27;s current state&quot;)\t&#125;\t// for setns process, we don&#x27;t have to set cloneflags as the process namespaces\t// will only be set via setns syscall\tdata, err := c.bootstrapData(0, state.NamespacePaths)\tif err != nil &#123; return nil, err\t&#125;\treturn &amp;setnsProcess&#123; cmd: cmd, cgroupPaths: c.cgroupManager.GetPaths(), rootlessCgroups: c.config.RootlessCgroups, intelRdtPath: state.IntelRdtPath, messageSockPair: messageSockPair, logFilePair: logFilePair, config: c.newInitConfig(p), process: p, bootstrapData: data,\t&#125;, nil&#125; libcontainer&#x2F;container_linux.go:512 123456789101112131415161718192021222324252627282930func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) &#123; // 这里通过环境变量 _LIBCONTAINER_INITTYPE 设置 init 类型为 standard（initStandard\tcmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_INITTYPE=&quot;+string(initStandard))\tnsMaps := make(map[configs.NamespaceType]string)\tfor _, ns := range c.config.Namespaces &#123; if ns.Path != &quot;&quot; &#123; nsMaps[ns.Type] = ns.Path &#125;\t&#125;\t_, sharePidns := nsMaps[configs.NEWPID] // 构造 namespace 设置，然后序列化成字节数据\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\tif err != nil &#123; return nil, err\t&#125;\tinit := &amp;initProcess&#123; cmd: cmd, messageSockPair: messageSockPair, logFilePair: logFilePair, manager: c.cgroupManager, intelRdtManager: c.intelRdtManager, config: c.newInitConfig(p), container: c, process: p, bootstrapData: data, sharePidns: sharePidns,\t&#125;\tc.initProcess = init return init, nil //返回init&#125; parent.start()执行 libcontainer&#x2F;process_linux.go:86 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172func (p *setnsProcess) start() (err error) &#123;\tdefer p.messageSockPair.parent.Close() // 启动了 cmd，即启动了 runc init（进入runc init逻辑）\terr = p.cmd.Start() // close the write-side of the pipes (controlled by child)\tp.messageSockPair.child.Close()\tp.logFilePair.child.Close()\tif err != nil &#123; return newSystemErrorWithCause(err, &quot;starting setns process&quot;)\t&#125;\tif p.bootstrapData != nil &#123; // 将 bootstrapData 写入到 parent pipe 中，此时 runc init 可以从 child pipe 里读取到这个数据 if _, err := io.Copy(p.messageSockPair.parent, p.bootstrapData); err != nil &#123; return newSystemErrorWithCause(err, &quot;copying bootstrap data to pipe&quot;) &#125;\t&#125;\tif err = p.execSetns(); err != nil &#123; return newSystemErrorWithCause(err, &quot;executing setns process&quot;)\t&#125; if len(p.cgroupPaths) &gt; 0 &#123; // 将pid加入cgroup if err := cgroups.EnterPid(p.cgroupPaths, p.pid()); err != nil &amp;&amp; !p.rootlessCgroups &#123; return newSystemErrorWithCausef(err, &quot;adding pid %d to cgroups&quot;, p.pid()) &#125;\t&#125;\tif p.intelRdtPath != &quot;&quot; &#123; // Intel RDT 资源控制 _, err := os.Stat(p.intelRdtPath) if err == nil &#123; if err := intelrdt.WriteIntelRdtTasks(p.intelRdtPath, p.pid()); err != nil &#123; return newSystemErrorWithCausef(err, &quot;adding pid %d to Intel RDT resource control filesystem&quot;, p.pid()) &#125; &#125;\t&#125;\t// set rlimits, this has to be done here because we lose permissions\t// to raise the limits once we enter a user-namespace\tif err := setupRlimits(p.config.Rlimits, p.pid()); err != nil &#123; return newSystemErrorWithCause(err, &quot;setting rlimits for process&quot;)\t&#125; // 将容器 config 配置写入 parent pipe 中,也就是把容器配置传递给了 runc init\tif err := utils.WriteJSON(p.messageSockPair.parent, p.config); err != nil &#123; return newSystemErrorWithCause(err, &quot;writing config to pipe&quot;)\t&#125; // 从 parent pipe 中读取来自 runc init 的同步消息\tierr := parseSync(p.messageSockPair.parent, func(sync *syncT) error &#123; switch sync.Type &#123; case procReady: // This shouldn&#x27;t happen. panic(&quot;unexpected procReady in setns&quot;) case procHooks: // This shouldn&#x27;t happen. panic(&quot;unexpected procHooks in setns&quot;) default: return newSystemError(fmt.Errorf(&quot;invalid JSON payload from child&quot;)) &#125;\t&#125;) // 关闭 init pipe\tif err := unix.Shutdown(int(p.messageSockPair.parent.Fd()), unix.SHUT_WR); err != nil &#123; return newSystemErrorWithCause(err, &quot;calling shutdown on init pipe&quot;)\t&#125;\t// Must be done after Shutdown so the child will exit and we can wait for it.\tif ierr != nil &#123; p.wait() return ierr\t&#125;\treturn nil&#125; libcontainer&#x2F;container_linux.go:1945 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384func (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) &#123;\t// create the netlink message\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\t// write cloneFlags\tr.AddData(&amp;Int32msg&#123; Type: CloneFlagsAttr, Value: uint32(cloneFlags),\t&#125;)\t// write custom namespace paths\tif len(nsMaps) &gt; 0 &#123; nsPaths, err := c.orderNamespacePaths(nsMaps) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: NsPathsAttr, Value: []byte(strings.Join(nsPaths, &quot;,&quot;)), &#125;)\t&#125;\t// write namespace paths only when we are not joining an existing user ns\t_, joinExistingUser := nsMaps[configs.NEWUSER]\tif !joinExistingUser &#123; // write uid mappings if len(c.config.UidMappings) &gt; 0 &#123; if c.config.RootlessEUID &amp;&amp; c.newuidmapPath != &quot;&quot; &#123; r.AddData(&amp;Bytemsg&#123; Type: UidmapPathAttr, Value: []byte(c.newuidmapPath), &#125;) &#125; b, err := encodeIDMapping(c.config.UidMappings) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: UidmapAttr, Value: b, &#125;) &#125; // write gid mappings if len(c.config.GidMappings) &gt; 0 &#123; b, err := encodeIDMapping(c.config.GidMappings) if err != nil &#123; return nil, err &#125; r.AddData(&amp;Bytemsg&#123; Type: GidmapAttr, Value: b, &#125;) if c.config.RootlessEUID &amp;&amp; c.newgidmapPath != &quot;&quot; &#123; r.AddData(&amp;Bytemsg&#123; Type: GidmapPathAttr, Value: []byte(c.newgidmapPath), &#125;) &#125; if requiresRootOrMappingTool(c.config) &#123; r.AddData(&amp;Boolmsg&#123; Type: SetgroupAttr, Value: true, &#125;) &#125; &#125;\t&#125;\tif c.config.OomScoreAdj != nil &#123; // write oom_score_adj r.AddData(&amp;Bytemsg&#123; Type: OomScoreAdjAttr, Value: []byte(fmt.Sprintf(&quot;%d&quot;, *c.config.OomScoreAdj)), &#125;)\t&#125;\t// write rootless\tr.AddData(&amp;Boolmsg&#123; Type: RootlessEUIDAttr, Value: c.config.RootlessEUID,\t&#125;)\treturn bytes.NewReader(r.Serialize()), nil&#125; libcontainer&#x2F;container_linux.go:566 1234567891011121314151617181920212223242526272829303132333435func (c *linuxContainer) newInitConfig(process *Process) *initConfig &#123;\tcfg := &amp;initConfig&#123; Config: c.config, Args: process.Args, Env: process.Env, User: process.User, AdditionalGroups: process.AdditionalGroups, Cwd: process.Cwd, Capabilities: process.Capabilities, PassedFilesCount: len(process.ExtraFiles), ContainerId: c.ID(), NoNewPrivileges: c.config.NoNewPrivileges, RootlessEUID: c.config.RootlessEUID, RootlessCgroups: c.config.RootlessCgroups, AppArmorProfile: c.config.AppArmorProfile, ProcessLabel: c.config.ProcessLabel, Rlimits: c.config.Rlimits,\t&#125;\tif process.NoNewPrivileges != nil &#123; cfg.NoNewPrivileges = *process.NoNewPrivileges\t&#125;\tif process.AppArmorProfile != &quot;&quot; &#123; cfg.AppArmorProfile = process.AppArmorProfile\t&#125;\tif process.Label != &quot;&quot; &#123; cfg.ProcessLabel = process.Label\t&#125;\tif len(process.Rlimits) &gt; 0 &#123; cfg.Rlimits = process.Rlimits\t&#125;\tcfg.CreateConsole = process.ConsoleSocket != nil\tcfg.ConsoleWidth = process.ConsoleWidth\tcfg.ConsoleHeight = process.ConsoleHeight\treturn cfg&#125; libcontainer&#x2F;container_linux.go:266 1234567891011121314151617181920func (c *linuxContainer) exec() error &#123;\tpath := filepath.Join(c.root, execFifoFilename)\tfifoOpen := make(chan struct&#123;&#125;)\tselect &#123;\tcase &lt;-awaitProcessExit(c.initProcess.pid(), fifoOpen): return errors.New(&quot;container process is already dead&quot;)\tcase result := &lt;-awaitFifoOpen(path): close(fifoOpen) if result.err != nil &#123; return result.err &#125; f := result.file defer f.Close() if err := readFromExecFifo(f); err != nil &#123; return err &#125; return os.Remove(path)\t&#125;&#125; 参考 深入理解Docker容器引擎runC执行框架","tags":["docker","runc"],"categories":["技术文档","docker源码分析","RunC"]},{"title":"Hexo 基础命令","path":"/2023/01/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":["hexo","stellar"],"categories":["技术文档","操作指南"]},{"title":"运维团队知识库系统","path":"/wiki/wekan/index.html","content":"wekan 是系统运维团队内部统一的知识库系统，为团队提供在成长过程对知识、经验的不断沉淀的机制，实现与帮助团队成员相互成长与新成员技术能力快速提升。 快速访问技术分享主页桌面问题DevOps问题DataOps问题故障总结 系统更新2023 年 1 月 15 日周末两天将知识库系统主要部分功能已经开发完成。2023 年 1 月 16 日快放春节假了，快速部署上线，尽量在春节假期前同步给组内测试。2023 年 2 月 1 日计划组内开启正式使用系统，提交相应技术文章。 文档仓库"},{"title":"桌面问题与处理","path":"/wiki/helpdesk/index.html","content":"#2023年度 问题汇总 1 月样例： 2023/01/17 [问题描述] 无法启动登录系统申请人: XiaoYang跟进人: XiaoYang02原因描述: 由于系统更新未完成且卡死状态，需要重新重启MacOS系统后恢复 处理详情: 1）现场检测与观察现象，电脑处于卡死状态（附截图），沟通有系统自动升级操作。 2）尝试重启MacOS系统后重新恢复未完成的系统更新进程。 3）待更新完成后可正常登录系统 2023/01/17 [问题描述] 电脑无法正常上网申请人: XiaoYang跟进人: XiaoYang02原因描述: XXXXXXX 处理详情: XXXXXXXXXXXXX 2023/01/17 [问题描述] 打开Excel文件就卡死了申请人: XiaoYang跟进人: XiaoYang02原因描述: XXXXXXX 处理详情: XXXXXXXXXXXXX 问题汇总 2 月问题汇总 3 月问题汇总 4 月问题汇总 5 月问题汇总 6 月问题汇总 7 月问题汇总 8 月问题汇总 9 月问题汇总 10 月问题汇总 11 月问题汇总 12 月#2024年度"}]